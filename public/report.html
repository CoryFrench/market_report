<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Area Analysis Report</title>
    <link rel="stylesheet" href="/styles.css">
    <link rel="icon" type="image/png" href="/logo.png">
    <!-- Chart.js for interactive charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script>
        // Improve canvas rendering quality on mobile by ensuring a reasonable device pixel ratio
        (function() {
            if (window.Chart) {
                Chart.defaults.responsive = true;
                Chart.defaults.maintainAspectRatio = false;
                // Cap DPR to avoid massive buffers, but keep crispness to prevent pixelation
                Chart.defaults.devicePixelRatio = function() { return Math.min(window.devicePixelRatio || 1, 2); };
                // Debug plugin removed; disable chart layout logging

                const angledTickDefaults = {
                    maxRotation: 48,
                    minRotation: 48,
                    autoSkipPadding: 12,
                    align: 'end'
                };

                function applyAngledTicks(scaleKey) {
                    Chart.defaults.scales = Chart.defaults.scales || {};
                    const scale = Chart.defaults.scales[scaleKey] = Chart.defaults.scales[scaleKey] || {};
                    const existing = scale.ticks || {};
                    scale.ticks = Object.assign({}, existing, angledTickDefaults);
                }

                ['category', 'time', 'timeseries'].forEach(applyAngledTicks);
            }
        })();

        // Dynamic container sizing using ResizeObserver (prevents clipping without fixed heights)
        function computeChartHeight(containerEl) {
            const width = containerEl.clientWidth || window.innerWidth;
            const vh = window.innerHeight || 360;
            const landscape = window.innerWidth > window.innerHeight;
            const isMobile = window.innerWidth <= 768;
            const ratio = isMobile ? (landscape ? 2.2 : 1.45) : (landscape ? 1.8 : 1.6); // width / height
            const byWidth = Math.round(width / ratio);
            const byViewport = Math.round(vh * (isMobile ? (landscape ? 0.55 : 0.50) : (landscape ? 0.60 : 0.65)));
            const height = Math.max(180, Math.min(byWidth, byViewport));
            // debug disabled
            return height;
        }

        function sizeChartContainer(container) {
            if (!container) return;
            const newHeight = computeChartHeight(container);
            container.style.height = newHeight + 'px';
            // debug disabled
        }

        function getNationalWrappers() {
            const left = document.getElementById('leftChart');
            const right = document.getElementById('rightChart');
            return [left && left.parentElement, right && right.parentElement].filter(Boolean);
        }

        function updateChartContainers() {
            try {
                const targets = [
                    document.getElementById('comparison-chart-container'),
                    document.getElementById('dev-comparison-chart-container'),
                    document.getElementById('wealth-migration-chart-container'),
                    ...getNationalWrappers()
                ].filter(Boolean);
                targets.forEach(sizeChartContainer);
                syncWealthMigrationListHeight();
                // Ask charts to reflow
                [window.leftChartInstance, window.rightChartInstance, window.comparisonChartInstance, window.developmentChart]
                    .forEach(c => { if (c && c.resize) c.resize(); });
            } catch {}
        }

        function syncWealthMigrationListHeight() {
            try {
                const card = document.getElementById('wealthMigrationListCard');
                const scroll = document.getElementById('wealthMigrationScroll');
                const chart = document.getElementById('wealth-migration-chart-container');
                if (!card || !scroll) return;

                if (!chart || window.innerWidth <= 900) {
                    card.style.removeProperty('height');
                    scroll.style.removeProperty('max-height');
                    return;
                }

                const chartHeight = chart.getBoundingClientRect().height;
                if (!chartHeight || Number.isNaN(chartHeight)) return;

                card.style.height = `${chartHeight}px`;

                const cardStyles = window.getComputedStyle(card);
                const paddingY = parseFloat(cardStyles.paddingTop || '0') + parseFloat(cardStyles.paddingBottom || '0');
                const header = document.getElementById('wealthMigrationListTitle');
                const headerHeight = header ? header.getBoundingClientRect().height : 0;
                const headerStyles = header ? window.getComputedStyle(header) : null;
                const headerMargin = headerStyles ? parseFloat(headerStyles.marginBottom || '0') : 0;
                const available = chartHeight - paddingY - headerHeight - headerMargin;
                scroll.style.maxHeight = `${Math.max(160, available)}px`;
            } catch {}
        }

        document.addEventListener('DOMContentLoaded', () => {
            updateChartContainers();
            syncWealthMigrationListHeight();
            const ro = new ResizeObserver(() => updateChartContainers());
            const watchEls = [
                document.getElementById('comparison-chart-container'),
                document.getElementById('dev-comparison-chart-container'),
                document.getElementById('wealth-migration-chart-container'),
                ...getNationalWrappers()
            ].filter(Boolean);
            watchEls.forEach(el => ro.observe(el));
            window.addEventListener('resize', () => {
                updateChartContainers();
            });
        });
    </script>
    <!-- Leaflet CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Define API_BASE early so all subsequent scripts can use it
        (function(){
            const p = window.location.pathname || '/';
            const firstSeg = '/' + (p.split('/')[1] || '');
            if (firstSeg === '/wealth') {
                window.API_BASE = '/wealth/api';
            } else if (firstSeg === '/report') {
                window.API_BASE = '/report/api';
            } else {
                window.API_BASE = '/api';
            }
        })();
        const API_BASE = window.API_BASE;

        const HTML_ESCAPE_MAP = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '/': '&#47;'
        };

        function escapeHtml(value) {
            if (value === null || value === undefined) return '';
            return String(value).replace(/[&<>"'/]/g, char => HTML_ESCAPE_MAP[char] || char);
        }

        const REALTOR_METRICS = [
            { key: 'avg_listing_price', label: 'Average Listing Price', valueType: 'currency', decimals: 0 },
            { key: 'median_listing_price_proxy', label: 'Median Listing Price (proxy)', valueType: 'currency', decimals: 0 },
            { key: 'avg_price_per_sqft', label: 'Average Price per Sq Ft', valueType: 'currency', decimals: 0 },
            { key: 'avg_days_on_market', label: 'Average Days on Market', valueType: 'number', decimals: 0 },
            { key: 'active_listing_count', label: 'Active Listings', valueType: 'number', decimals: 0 },
            { key: 'new_listing_count', label: 'New Listings', valueType: 'number', decimals: 0 },
            { key: 'total_listing_count', label: 'Total Listings', valueType: 'number', decimals: 0 },
            { key: 'pending_ratio', label: 'Pending Ratio', valueType: 'ratio', percentDecimals: 1 },
            { key: 'price_increased_share', label: 'Price Increased Share', valueType: 'ratio', percentDecimals: 1 },
            { key: 'price_reduced_share', label: 'Price Reduced Share', valueType: 'ratio', percentDecimals: 1 }
        ];
        const DEFAULT_COUNTY_METRIC = REALTOR_METRICS[0]?.key || 'avg_listing_price';
        const realtorSeriesKeys = new Set(REALTOR_METRICS.map(m => m.key));
        const DEVELOPMENT_CHART_TYPES = {
            sales: { dataKey: 'sales_count', title: 'Sales Count', axisLabel: 'Number of Sales', valueType: 'number' },
            sales_yoy: { dataKey: 'sales_count', title: 'Sales Count YoY % Change', axisLabel: 'YoY % Change', valueType: 'percent', decimals: 1, yoy: true },
            price: { dataKey: 'avg_price', title: 'Average Sale Price', axisLabel: 'Average Sale Price', valueType: 'currency', decimals: 0 },
            price_yoy: { dataKey: 'avg_price', title: 'Average Sale Price YoY % Change', axisLabel: 'YoY % Change', valueType: 'percent', decimals: 1, yoy: true },
            price_per_sqft: { dataKey: 'avg_price_per_sqft', title: 'Average Price Per Square Foot', axisLabel: 'Average Price Per Square Foot', valueType: 'currency', decimals: 0, requiresPricePerSqft: true },
            price_per_sqft_yoy: { dataKey: 'avg_price_per_sqft', title: 'Price Per Square Foot YoY % Change', axisLabel: 'YoY % Change', valueType: 'percent', decimals: 1, yoy: true, requiresPricePerSqft: true }
        };
        const STATE_ABBR_TO_NAME = {
            AL: 'Alabama', AK: 'Alaska', AZ: 'Arizona', AR: 'Arkansas', CA: 'California', CO: 'Colorado',
            CT: 'Connecticut', DE: 'Delaware', FL: 'Florida', GA: 'Georgia', HI: 'Hawaii', ID: 'Idaho',
            IL: 'Illinois', IN: 'Indiana', IA: 'Iowa', KS: 'Kansas', KY: 'Kentucky', LA: 'Louisiana',
            ME: 'Maine', MD: 'Maryland', MA: 'Massachusetts', MI: 'Michigan', MN: 'Minnesota',
            MS: 'Mississippi', MO: 'Missouri', MT: 'Montana', NE: 'Nebraska', NV: 'Nevada',
            NH: 'New Hampshire', NJ: 'New Jersey', NM: 'New Mexico', NY: 'New York', NC: 'North Carolina',
            ND: 'North Dakota', OH: 'Ohio', OK: 'Oklahoma', OR: 'Oregon', PA: 'Pennsylvania',
            RI: 'Rhode Island', SC: 'South Carolina', SD: 'South Dakota', TN: 'Tennessee', TX: 'Texas',
            UT: 'Utah', VT: 'Vermont', VA: 'Virginia', WA: 'Washington', WV: 'West Virginia',
            WI: 'Wisconsin', WY: 'Wyoming', DC: 'District of Columbia'
        };
        const DEFAULT_WEALTH_MIGRATION_STATE = 'Florida';
        const WEALTH_MIGRATION_LIMIT = 15;
        let wealthMigrationChartInstance = null;
        let wealthMigrationDirection = 'inflow';
        let wealthMigrationState = DEFAULT_WEALTH_MIGRATION_STATE;
        let wealthMigrationCountyFips = null;
        let wealthMigrationCountyName = '';
        let wealthMigrationPayload = {
            stateName: DEFAULT_WEALTH_MIGRATION_STATE,
            countyName: '',
            countyFips: null,
            latestYear: null,
            inflow: [],
            outflow: []
        };
        let wealthMigrationStateOptions = [];
        let wealthMigrationStateLookup = new Map();
        let wealthMigrationStateFips = '12';
        const WEALTH_MIGRATION_EXCLUDE_PATTERNS = [
            /non-?migrant/i,
            /total migration\s*-\s*same state/i,
            /total migration\s*-\s*different state/i,
            /total migration\s*-\s*us(?: and foreign)?/i,
            /total migration-?us/i,
            /total migration/i,
            /within county/i
        ];

        function formatMetricValue(value, meta) {
            if (value == null || Number.isNaN(value)) return '-';
            if (!meta || meta.valueType === 'number') {
                return Number(value).toLocaleString();
            }
            if (meta.valueType === 'currency') {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    maximumFractionDigits: meta.decimals ?? 0,
                    minimumFractionDigits: meta.decimals ?? 0
                }).format(value);
            }
            if (meta.valueType === 'ratio') {
                const percent = Number(value) * 100;
                const decimals = meta.percentDecimals ?? 1;
                return `${percent.toFixed(decimals)}%`;
            }
            if (meta.valueType === 'percent') {
                const decimals = meta.decimals ?? meta.percentDecimals ?? 1;
                return `${Number(value).toFixed(decimals)}%`;
            }
            return Number(value).toLocaleString();
        }

        function computeYAxisConfig(meta, datasets) {
            const values = datasets.flatMap(ds => (ds.data || []).map(point => {
                if (point == null) return null;
                if (typeof point === 'number') return point;
                if (typeof point === 'object' && typeof point.y === 'number') return point.y;
                if (typeof point === 'object' && typeof point.value === 'number') return point.value;
                return null;
            }).filter(v => v != null && !Number.isNaN(v)));
            if (values.length === 0) {
                return {};
            }
            if (meta && meta.valueType === 'ratio') {
                return {
                    beginAtZero: true,
                    suggestedMax: Math.min(1, Math.max(...values) * 1.05 || 0.5),
                    ticks: {
                        callback: (v) => `${Math.round(v * 100)}%`
                    }
                };
            }
            if (meta && meta.valueType === 'percent') {
                const min = Math.min(...values);
                const max = Math.max(...values);
                const pad = (max - min) * 0.1 || 5;
                const suggestedMin = Math.min(0, min - pad);
                const suggestedMax = Math.max(0, max + pad);
                return {
                    suggestedMin,
                    suggestedMax,
                    ticks: {
                        callback: (v) => `${Number(v).toFixed(meta.decimals ?? 0)}%`
                    }
                };
            }
            const decimals = meta && meta.valueType === 'currency' ? (meta.decimals ?? 0) : 0;
            const min = Math.min(...values);
            const max = Math.max(...values);
            const pad = (max - min) * 0.08 || (meta && meta.valueType === 'currency' ? 1000 : 10);
            return {
                suggestedMin: Math.max(0, min - pad),
                suggestedMax: max + pad * 0.5,
                ticks: {
                    callback: (v) => {
                        if (meta && meta.valueType === 'currency') {
                            return new Intl.NumberFormat('en-US', {
                                style: 'currency',
                                currency: 'USD',
                                maximumFractionDigits: decimals,
                                minimumFractionDigits: decimals
                            }).format(v);
                        }
                        return Number(v).toLocaleString();
                    }
                }
            };
        }

        async function fetchCountySeriesData(countyIds, metricKey) {
            if (!Array.isArray(countyIds) || countyIds.length === 0) {
                return [];
            }
            const metricMeta = REALTOR_METRICS.find(m => m.key === metricKey) || null;
            console.debug('Fetch county comparison start', { countyIds, metricKey, apiBase: API_BASE });
            const params = new URLSearchParams();
            params.set('county_fips', countyIds.join(','));
            params.set('months', '60');
            const response = await fetch(`${API_BASE}/county-comparison?${params.toString()}`);
            if (!response.ok) {
                throw new Error('Failed to fetch county comparison data');
            }
            const json = await response.json();
            if (!json.success || !Array.isArray(json.data)) {
                return [];
            }
            console.debug('County comparison API payload', {
                metric: metricKey,
                count: json.data.length,
                sample: json.data.slice(0, 5)
            });
            const grouped = {};
            json.data.forEach(row => {
                const countyId = row.county_fips;
                if (!row || row[metricKey] === undefined) {
                    console.warn('Missing metric in row for county comparison', { metricKey, row });
                }
                if (!grouped[countyId]) {
                    grouped[countyId] = {
                        county: countyId,
                        name: row.county_name,
                        points: []
                    };
                }
                const parsedDate = parseYyyymmToDate(row.month_date_yyyymm);
                const parsedValue = toNumberOrNull(row[metricKey]);
                if (!parsedDate || parsedValue === null) {
                    console.warn('Skipping data point due to invalid value or date', {
                        countyId,
                        metricKey,
                        rawValue: row[metricKey],
                        parsedDate,
                        parsedValue,
                        row
                    });
                }
                grouped[countyId].points.push({
                    x: parsedDate,
                    y: parsedValue
                });
            });
            return Object.values(grouped).map(entry => {
                entry.points.sort((a, b) => (a.x?.getTime?.() || 0) - (b.x?.getTime?.() || 0));
                entry.meta = metricMeta;
                return entry;
            });
        }
    </script>
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Development Chart Legend Clickable Styling */
        #dev-comparison-chart + div .chartjs-legend li,
        .chartjs-legend-item {
            cursor: pointer !important;
            transition: all 0.2s ease;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        #dev-comparison-chart + div .chartjs-legend li:hover,
        .chartjs-legend-item:hover {
            background-color: rgba(52, 152, 219, 0.1);
            transform: translateY(-1px);
        }
        
        /* Development Actions Popup */
        #developmentActionsPopup {
            position: fixed !important;
            z-index: 9999 !important;
            display: none !important;
            background: white !important;
            border: 1px solid #ddd !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
            padding: 12px !important;
            min-width: 160px !important;
            max-width: 200px !important;
        }
        
        #developmentActionsPopup[style*="display: block"] {
            display: block !important;
        }
        
        #developmentActionsPopup button:hover {
            background-color: #f8f9fa !important;
            border-color: #adb5bd !important;
            transform: translateY(-1px) !important;
        }

        /* Custom Development HTML Legend */
        #devLegend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 6px 0 12px 0;
        }
        #devLegend .legend-item {
            background: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 6px 10px;
            min-width: 150px;
            text-align: center;
        }
        #devLegend .legend-name {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #2c3e50;
            cursor: pointer;
        }
        #devLegend .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        #devLegend .legend-actions {
            margin-top: 2px;
            font-size: 12px;
            color: #6c757d;
        }
        #devLegend .legend-actions a {
            color: #3498db;
            text-decoration: none;
            margin: 0 4px;
            cursor: pointer;
        }
        #devLegend .legend-actions a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="letterhead">
            <div class="header-info">
                <div class="header-item">
                    <div class="header-label">Prepared by</div>
                    <div class="header-value" id="agentName">Agent Name</div>
                </div>
                <div class="header-logo">
                    <img id="headerLogo" src="/logo.png" alt="Logo" />
                </div>
                <div class="header-item">
                    <div class="header-label">Prepared for</div>
                    <div class="header-value" id="buyerName">Buyer Name</div>
                </div>
                <!-- Keep ZIP node in DOM for script compatibility but hide visually -->
                <div class="header-item" id="zipHeaderItem" style="display:none; visibility:hidden;">
                    <div class="header-label">Zip</div>
                    <div class="header-value" id="zipCode">ZIP Code</div>
                </div>
            </div>
        </div>

        <div class="content">
            
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <p>Loading comprehensive market analysis...</p>
            </div>

            <div id="error" class="error" style="display: none;">
                <h3>Analysis Not Found</h3>
                <p>The requested area analysis could not be located. Please verify the report URL.</p>
            </div>
            <div id="reportContent" style="display: none; flex-direction: column; gap: 24px;">

                <div class="section" id="wealth-migration-section" style="order: 5;">
                    <h2>Wealth Migration</h2>
                    <div class="section-content">
                        <div class="wealth-migration-card">
                            <div class="wealth-migration-header">
                                <div class="wealth-migration-summary">
                                    <p class="wealth-migration-eyebrow">Focus County</p>
                                    <div class="wealth-focus-line" id="wealthMigrationFocus">
                                        <label for="wealthMigrationCountySelect" class="sr-only"></label>
                                        <span class="wealth-focus-select-wrapper">
                                            <select id="wealthMigrationCountySelect" class="wealth-focus-select wealth-focus-select--county" disabled>
                                                <option value="">Select a state</option>
                                            </select>
                                        </span>
                                        <span class="wealth-focus-comma">,</span>
                                        <label for="wealthMigrationStateSelect" class="sr-only"></label>
                                        <span class="wealth-focus-select-wrapper">
                                            <select id="wealthMigrationStateSelect" class="wealth-focus-select wealth-focus-select--state"></select>
                                        </span>
                                    </div>
                                    <p class="wealth-migration-subtitle" id="wealthMigrationYear">Awaiting data</p>
                                </div>
                                <div class="wealth-migration-toggle" role="group" aria-label="Select migration direction">
                                    <button type="button" class="wealth-toggle-btn active" data-direction="inflow">Inbound</button>
                                    <button type="button" class="wealth-toggle-btn" data-direction="outflow">Outbound</button>
                                </div>
                            </div>
                            <div class="wealth-migration-body">
                                <div class="wealth-chart-wrapper" id="wealth-migration-chart-container">
                                    <canvas id="wealthMigrationChart" aria-label="Wealth migration chart"></canvas>
                                    <div id="wealthMigrationChartLoading" class="chart-loading-message" style="display:none;">
                                        <div class="loading-spinner-small"></div>
                                        <p>Loading wealth migration insights...</p>
                                    </div>
                                    <div id="wealthMigrationChartFallback" class="chart-empty-state" hidden>
                                        <p>Wealth migration chart is unavailable for this county.</p>
                                    </div>
                                </div>
                <div class="wealth-migration-list" id="wealthMigrationListCard">
                    <h4 id="wealthMigrationListTitle">Top Origins (Counties)</h4>
                    <div class="wealth-migration-scroll" id="wealthMigrationScroll">
                        <ol id="wealthMigrationList" class="wealth-list"></ol>
                        <div id="wealthMigrationListEmpty" class="info-value" style="display:none;">No migration records were found for this direction.</div>
                    </div>
                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section" id="national-section" style="order: 0;">
                    <h2>National Charts</h2>
                    <div class="section-content">
                        <div id="fredChartsContent" style="display: flex; gap: 20px; flex-wrap: wrap;">
                            <div class="chart-container" style="flex: 1; min-width: 300px; border: 1px solid #ddd; border-radius: 8px; padding: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-bottom: 10px;">
                                    <h3 style="margin: 0; color: #333; font-size: 20px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1;" id="leftChartTitle"><span id="leftChartTitleText">Housing Price Index</span><div id="leftChartSubtitle" class="chart-subtitle">Source: Federal Reserve</div></h3>
                                    <button id="leftInfoIcon" class="chart-info-button" aria-label="What does this mean?">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <circle cx="12" cy="12" r="10"></circle>
                                            <line x1="12" y1="16" x2="12" y2="12"></line>
                                            <line x1="12" y1="8" x2="12" y2="8"></line>
                                        </svg>
                                    </button>
                                    
                                    <select id="leftChartSelect" style="padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px;">
                                        <option value="DGS2">2-Year Treasury</option>
                                        <option value="DGS10">10-Year Treasury</option>
                                        <option value="MORTGAGE15US">15-Year Mortgage</option>
                                        <option value="MORTGAGE30US">30-Year Mortgage</option>
                                        <option value="ACTLISCOUUS">Active Listings</option>
                                        <option value="CPIAUCSL">CPI</option>
                                        <option value="DJIA">Dow Jones Industrial Average</option>
                                        <option value="LREM64TTUSM156S">Employment</option>
                                        <option value="FEDFUNDS">Fed Funds Rate</option>
                                        <option value="GDP">GDP</option>
                                        <option value="GFDEBTN">Government Debt</option>
                                        <option value="USSTHPI">Housing Price Index</option>
                                        <option value="FPCPITOTLZGUSA">Inflation</option>
                                        <option value="MEDDAYONMARUS">Median Days on Market</option>
                                        <option value="MSPUS">Median Sale Price</option>
                                        <option value="M2REAL">Money Stock</option>
                                        <option value="NEWLISCOUUS">New Listings</option>
                                        <option value="POPTHM">Population</option>
                                        <option value="PPIACO">PPI</option>
                                        <option value="UNRATE">Unemployment Rate</option>
                                        <option value="RHVRUSQ156N">Vacancy Rate</option>
                                    </select>
                                </div>
                                <div style="position: relative; width: 100%; height: 300px; background-color: #f9f9f9; border-radius: 4px;">
                                    <canvas id="leftChart" style="width: 100%; height: 100%;"></canvas>
                                    <div id="leftChart-loading" class="loading-spinner" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                                        <div style="border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 2s linear infinite; margin: 0 auto;"></div>
                                        <p style="margin-top: 10px; color: #666;">Loading chart data...</p>
                                    </div>
                                </div>
                                <div id="leftChartDescription" style="display: none;"></div>
                            </div>
                            
                            <div class="chart-container" style="flex: 1; min-width: 300px; border: 1px solid #ddd; border-radius: 8px; padding: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-bottom: 10px;">
                                    <h3 style="margin: 0; color: #333; font-size: 20px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1;" id="rightChartTitle"><span id="rightChartTitleText">Dow Jones Industrial Average</span><div id="rightChartSubtitle" class="chart-subtitle">Source: Federal Reserve</div></h3>
                                    <button id="rightInfoIcon" class="chart-info-button" aria-label="What does this mean?">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <circle cx="12" cy="12" r="10"></circle>
                                            <line x1="12" y1="16" x2="12" y2="12"></line>
                                            <line x1="12" y1="8" x2="12" y2="8"></line>
                                        </svg>
                                    </button>
                                    <select id="rightChartSelect" style="padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px;">
                                        <option value="DGS2">2-Year Treasury</option>
                                        <option value="DGS10">10-Year Treasury</option>
                                        <option value="MORTGAGE15US">15-Year Mortgage</option>
                                        <option value="MORTGAGE30US">30-Year Mortgage</option>
                                        <option value="ACTLISCOUUS">Active Listings</option>
                                        <option value="CPIAUCSL">CPI</option>
                                        <option value="DJIA" selected>Dow Jones Industrial Average</option>
                                        <option value="LREM64TTUSM156S">Employment</option>
                                        <option value="FEDFUNDS">Fed Funds Rate</option>
                                        <option value="GDP">GDP</option>
                                        <option value="GFDEBTN">Government Debt</option>
                                        <option value="USSTHPI">Housing Price Index</option>
                                        <option value="FPCPITOTLZGUSA">Inflation</option>
                                        <option value="MEDDAYONMARUS">Median Days on Market</option>
                                        <option value="MSPUS">Median Sale Price</option>
                                        <option value="M2REAL">Money Stock</option>
                                        <option value="NEWLISCOUUS">New Listings</option>
                                        <option value="POPTHM">Population</option>
                                        <option value="PPIACO">PPI</option>
                                        <option value="UNRATE">Unemployment Rate</option>
                                        <option value="RHVRUSQ156N">Vacancy Rate</option>
                                    </select>
                                </div>
                                <div style="position: relative; width: 100%; height: 300px; background-color: #f9f9f9; border-radius: 4px;">
                                    <canvas id="rightChart" style="width: 100%; height: 100%;"></canvas>
                                    <div id="rightChart-loading" class="loading-spinner" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                                        <div style="border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 2s linear infinite; margin: 0 auto;"></div>
                                        <p style="margin-top: 10px; color: #666;">Loading chart data...</p>
                                    </div>
                                </div>
                                <div id="rightChartDescription" style="display: none;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section" id="home-section" style="order: 1;">
                    <h2>Home Stats</h2>
                    <div class="section-content">
                        <div id="homeStatsContent" style="display: flex; gap: 40px; min-height: 200px;">
                            <!-- Left Side - Property Information -->
                            <div style="flex: 1; padding: 25px; background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%); border-radius: 12px; border: 1px solid #e9ecef; box-shadow: 0 2px 8px rgba(0,0,0,0.04);">
                                <div style="margin-bottom: 20px;">
                                    <div id="propertyAddress" style="color: #34495e; font-size: 20px; font-weight: 500; margin-bottom: 8px; line-height: 1.4;">
                                        Loading address...
                                    </div>
                                    <div id="propertyDevelopment" style="color: #7f8c8d; font-size: 18px; margin-bottom: 6px;">
                                        Development information
                                    </div>
                                    <div id="propertySubdivision" style="color: #7f8c8d; font-size: 18px; margin-bottom: 20px;">
                                        Subdivision details
                                    </div>
                                    <!-- Address Lookup (RentCast-backed) -->
                                    <form id="homeLookupForm" style="display: grid; grid-template-columns: repeat(2, minmax(140px, 1fr)); gap: 10px; align-items: end; margin-top: 6px;">
                                        <div style="grid-column: 1 / -1;">
                                            <label for="hl_address" style="display:block; font-size:12px; color:#7f8c8d; margin-bottom:4px;">Address</label>
                                            <input id="hl_address" name="address" type="text" placeholder="123 Main St" style="width:100%; padding:10px 12px; border:1px solid #dee2e6; border-radius:8px;" />
                                        </div>
                                        <div>
                                            <label for="hl_city" style="display:block; font-size:12px; color:#7f8c8d; margin-bottom:4px;">City</label>
                                            <input id="hl_city" name="city" type="text" placeholder="City" style="width:100%; padding:10px 12px; border:1px solid #dee2e6; border-radius:8px;" />
                                        </div>
                                        <div>
                                            <label for="hl_state" style="display:block; font-size:12px; color:#7f8c8d; margin-bottom:4px;">State</label>
                                            <input id="hl_state" name="state" type="text" placeholder="FL" style="width:100%; padding:10px 12px; border:1px solid #dee2e6; border-radius:8px;" />
                                        </div>
                                        <div>
                                            <label for="hl_zip" style="display:block; font-size:12px; color:#7f8c8d; margin-bottom:4px;">ZIP</label>
                                            <input id="hl_zip" name="zip" type="text" placeholder="33408" style="width:100%; padding:10px 12px; border:1px solid #dee2e6; border-radius:8px;" />
                                        </div>
                                        <div>
                                            <button type="submit" id="hl_submit" style="width:100%; padding:10px 12px; background:#1e88e5; color:#fff; border:none; border-radius:8px; cursor:pointer;">Lookup</button>
                                        </div>
                                    </form>
                                    <div id="homeLookupResults" style="margin-top: 10px;"></div>
                                </div>
                                
                                <!-- Action Icons -->
                                <div style="display: flex; gap: 15px; padding-top: 15px; border-top: 1px solid #e9ecef;">
                                    <div id="mapButton" style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3498db" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                                            <circle cx="12" cy="10" r="3"></circle>
                                        </svg>
                                        <span style="color: #3498db; font-size: 13px; font-weight: 500;">Map</span>
                                    </div>
                                    <div id="chartButton" style="display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: #ffffff; border: 1px solid #dee2e6; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#27ae60" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="18" y1="20" x2="18" y2="10"></line>
                                            <line x1="12" y1="20" x2="12" y2="4"></line>
                                            <line x1="6" y1="20" x2="6" y2="14"></line>
                                        </svg>
                                        <span style="color: #27ae60; font-size: 13px; font-weight: 500;">Stats</span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Right Side - Stats -->
                            <div style="flex: 1; padding: 25px; background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); border-radius: 12px; border: 1px solid #e9ecef; box-shadow: 0 2px 8px rgba(0,0,0,0.04);">
                                <div style="display: flex; align-items: center; justify-content: center; height: 100%; min-height: 150px;">
                                    <div style="text-align: center;">
                                        <h3 style="margin: 0; color: #2c3e50; font-size: 24px; font-weight: 300; letter-spacing: 2px; text-transform: uppercase;">Stats</h3>
                                        <div style="width: 60px; height: 2px; background: linear-gradient(90deg, #3498db, #27ae60); margin: 15px auto;"></div>
                                        <p style="margin: 10px 0 0 0; color: #7f8c8d; font-size: 14px; font-style: italic;">Market analytics coming soon</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section" id="neighbourhood-section" style="order: 4;">
                    <h2 style="text-align: center;">Neighbourhood Charts</h2>
                    <div class="section-content">
                        <!-- Development Comparison Interface -->
                        <div id="developmentComparisonContainer">
                            <div style="border-top: 1px solid #e9ecef; padding-top: 30px;">
                                <h3 id="dev-comp-title" style="text-align: center; color: #2c3e50; margin-bottom: 20px;">Development Comparison Analysis</h3>
                                
                <!-- Development Comparison Controls -->
                <div class="comparison-controls" id="dev-controls-section">
                    <div class="locations-container">
                        <h4 id="dev-controls-title">Development Comparison Analysis</h4>
                        <div id="development-selections">
                            <!-- Dynamic development selectors will be added here -->
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button id="add-development-btn" class="add-location-btn">Add Development</button>
                        <button id="remove-development-btn" class="remove-location-btn" style="display: none;">Remove Development</button>
                        <button id="compare-developments-btn" class="compare-btn">
                            <span>Generate Analysis</span>
                        </button>
                        <button id="reset-development-comparison-btn" class="reset-btn">Reset to Default</button>
                    </div>
                </div>                                <!-- Development Comparison Chart View -->
                                <div class="chart-section" id="dev-chart-section" style="display: none;">
                                    <div class="chart-controls">
                                        <button id="back-to-dev-controls-btn" class="back-to-controls-btn">← Change Neighbourhood</button>
                                    </div>
                                    <div id="dev-comparison-chart-header" class="chart-header" style="display: none;">
                                        <h3 id="dev-chart-title">Development Sales Comparison</h3>
                                        <p id="dev-chart-subtitle">Comparative analysis of sales volume and pricing across selected developments</p>
                                    </div>
                                    <!-- Custom HTML legend lives OUTSIDE the chart container so it doesn't consume canvas height -->
                                    <div id="devLegend" class="dev-legend-bar"></div>
                                    <div id="development-chart-controls" style="display: none; text-align: center; margin-bottom: 20px;">
                                        <label for="development-chart-type-select" style="margin-right: 10px; font-weight: bold;">Chart Type:</label>
                                        <select id="development-chart-type-select" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; min-width: 150px;">
                                            <option value="sales">Sales Count</option>
                                            <option value="sales_yoy">Sales Count (YoY %)</option>
                                            <option value="price">Average Price</option>
                                            <option value="price_yoy">Average Price (YoY %)</option>
                                            <option value="price_per_sqft">Price Per Square Foot</option>
                                            <option value="price_per_sqft_yoy">Price Per Square Foot (YoY %)</option>
                                        </select>
                                    </div>
                                    <div id="dev-comparison-chart-container" style="position: relative; height: 500px; width: 100%;">
                                        <canvas id="dev-comparison-chart"></canvas>
                                        <div id="dev-chart-loading" class="chart-loading-message" style="display: none;">
                                            <div class="loading-spinner-small"></div>
                                            <p id="dev-chart-loading-text">Generating development comparison analysis...</p>
                                        </div>
                                        <div id="dev-chart-error" class="chart-error-message" style="display: none;">
                                            <p>Comparison temporarily unavailable. Please verify your selections and try again.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ZIP Insights (realtor.com ZIP-level) -->
                <div class="section" id="county-insights-section" style="display: none; order: 3;">
                    <h2>ZIP Insights</h2>
                    <div class="section-content">
                        <div class="chart-section" id="county-insights" style="display: none;">
                            <div class="comparison-controls" id="ci-controls-section" style="margin-bottom: 12px;">
                                <div class="locations-container">
                                    <h4 id="ci-controls-title">ZIP Insights Comparison</h4>
                                    <div id="ci-location-selections"></div>
                                </div>
                                <div class="action-buttons">
                                    <button id="ci-add-location-btn" class="add-location-btn">Add ZIP</button>
                                    <button id="ci-remove-location-btn" class="remove-location-btn" style="display: none;">Remove ZIP</button>
                                    <button id="ci-compare-btn" class="compare-btn">
                                        <span>Generate Insight</span>
                                    </button>
                                </div>
                            </div>
                            <div class="chart-controls" id="ci-chart-controls" style="display:none;">
                                <button id="ci-back-to-controls-btn" class="back-to-controls-btn">← Change ZIPs</button>
                                <div class="chart-indicator-control">
                                    <label for="county-insights-metric-select">Metric:</label>
                                    <select id="county-insights-metric-select" class="fred-select" style="min-width: 200px;">
                                        <option value="avg_listing_price" selected>Average Listing Price</option>
                                        <option value="median_listing_price_proxy">Median Listing Price (proxy)</option>
                                        <option value="avg_price_per_sqft">Average Price per Sq Ft</option>
                                        <option value="avg_days_on_market">Average Days on Market</option>
                                        <option value="active_listing_count">Active Listings</option>
                                        <option value="new_listing_count">New Listings</option>
                                        <option value="pending_ratio">Pending Ratio</option>
                                        <option value="price_increased_share">Price Increased Share</option>
                                        <option value="price_reduced_share">Price Reduced Share</option>
                                    </select>
                                </div>
                            </div>
                            <div id="county-insights-chart-container" style="position: relative; height: 420px; width: 100%; display: none;">
                                <canvas id="county-insights-chart"></canvas>
                                <div id="county-insights-loading" class="chart-loading-message" style="display: none;">
                                    <div class="loading-spinner-small"></div>
                                    <p>Loading ZIP insights…</p>
                                </div>
                                <div id="county-insights-error" class="chart-error-message" style="display: none;">
                                    <p>Insights unavailable for this ZIP at the moment.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section" id="county-section" style="order: 2;">
                    <h2>County Charts</h2>
                    <div class="section-content">
                        <div id="chartsContent">
                            <!-- Premium FRED Comparison Interface -->
                            <div class="fred-comparison-container" style="width: 100%;">
                                <div class="comparison-controls" id="controls-section">
                                    <div class="control-group">
                                        <label for="series-select">Economic Indicator Selection</label>
                                        <select id="series-select" class="fred-select">
                                            <option value="loading">Loading available metrics...</option>
                                        </select>
                                    </div>
                                    
                                    <div class="locations-container">
                                        <h4>Regional Comparison Analysis</h4>
                                        <div id="location-selections">
                                            <!-- Dynamic location selectors will be added here -->
                                        </div>
                                    </div>
                                    
                                    <div class="action-buttons">
                                        <button id="add-location-btn" class="add-location-btn">Add Location</button>
                                        <button id="remove-location-btn" class="remove-location-btn" style="display: none;">Remove Location</button>
                                        <button id="compare-btn" class="compare-btn">
                                            <span>Generate Analysis</span>
                                        </button>
                                        <button id="reset-comparison-btn" class="reset-btn">Reset to Default</button>
                                    </div>
                                </div>
                                
                                <div class="chart-section" id="chart-section" style="display: none;">
                                    <div class="chart-controls">
                                        <button id="back-to-controls-btn" class="back-to-controls-btn">← Change County</button>
                                        <div class="chart-indicator-control" style="margin-left: 20px; display: inline-flex; align-items: center; gap: 10px;">
                                            <label for="chart-series-select" style="font-weight: bold; color: #333;">Indicator:</label>
                                            <select id="chart-series-select" class="fred-select" style="min-width: 200px;">
                                                <option value="">Select Indicator...</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div id="comparison-chart-header" class="chart-header" style="display: none;">
                                        <h3>Comparative Market Analysis</h3>
                                    </div>
                                    <div id="comparison-chart-container" style="position: relative; height: 500px; width: 100%;">
                                        <canvas id="comparison-chart"></canvas>
                                        <div id="chart-loading" class="chart-loading-message" style="display: none;">
                                            <div class="loading-spinner-small"></div>
                                            <p>Generating comprehensive market analysis...</p>
                                        </div>
                                        <div id="chart-error" class="chart-error-message" style="display: none;">
                                            <p>Analysis temporarily unavailable. Please verify your selections and try again.</p>
                                        </div>
                                    </div>
                                    <div id="data-availability-notice" class="data-notice" style="display: none;">
                                        <!-- Professional notice for unavailable data will be inserted here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chart Overlay -->
        <div id="chartOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
            <div style="background: white; border-radius: 12px; padding: 30px; max-width: 900px; width: 90%; max-height: 80%; overflow-y: auto; position: relative;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px;">
                    <h2 style="margin: 0; color: #2c3e50;" id="chartOverlayTitle">Development Sales Analysis</h2>
                    <button id="closeChartOverlay" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #95a5a6; padding: 5px;">&times;</button>
                </div>
                
                <div id="chartOverlayContent">
                    <div style="text-align: center; padding: 40px;">
                        <div style="border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite; margin: 0 auto 20px;"></div>
                        <p style="color: #7f8c8d; font-size: 16px;">Loading sales chart data...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Development Actions Popup -->
        <div id="developmentActionsPopup" style="display: none; position: fixed; z-index: 9999; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px; min-width: 160px; max-width: 200px;">
            <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #eee;" id="developmentPopupTitle">
                Development Name
            </div>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <button id="developmentPopupMapBtn" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #ffffff; border: 1px solid #dee2e6; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; font-size: 13px;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#3498db" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                        <circle cx="12" cy="10" r="3"></circle>
                    </svg>
                    <span style="color: #3498db; font-weight: 500;">View Map</span>
                </button>
                <button id="developmentPopupChartBtn" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #ffffff; border: 1px solid #dee2e6; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; font-size: 13px;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#27ae60" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="20" x2="18" y2="10"></line>
                        <line x1="12" y1="20" x2="12" y2="4"></line>
                        <line x1="6" y1="20" x2="6" y2="14"></line>
                    </svg>
                    <span style="color: #27ae60; font-weight: 500;">View Chart</span>
                </button>
            </div>
        </div>

        <div class="footer">
            <div class="footer-content">
                <p>© 2025 Waterfront Properties. All rights reserved.</p>
                <p>This report was compiled by Waterfront Properties and provided exclusively for the intended recipient.</p>
            </div>
        </div>
    </div>
    <script>
        // Get report identifier from URL (could be lastname-id format or just ID)
        const urlParams = new URLSearchParams(window.location.search);
        let urlSlug = urlParams.get('id');
        
        // If no query parameter, extract from path
        if (!urlSlug) {
            const pathParts = window.location.pathname.split('/');
            urlSlug = pathParts[pathParts.length - 1]; // Get last part of path
        }
        
        // If still no slug or it's empty, show error
        if (!urlSlug || urlSlug === 'report.html') {
            console.error('No report identifier found in URL');
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
        }

        async function loadReport() {
            // Don't load if no URL slug
            if (!urlSlug || urlSlug === 'report.html') {
                return;
            }
            
            try {
                console.log('Loading report with slug:', urlSlug);
                const response = await fetch(`${API_BASE}/reports/complete/${urlSlug}`);
                const result = await response.json();

                console.log('API Response:', { status: response.status, result });
                document.getElementById('loading').style.display = 'none';

                if (response.ok && result.success) {
                    displayReport(result.data);
                } else {
                    console.error('API Error:', result.error || 'Unknown error');
                    document.getElementById('error').style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading report:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
            }
        }

        function displayReport(data) {
            console.log('Displaying report data:', data);
            document.getElementById('reportContent').style.display = 'flex';
            try { delete window._zipOnlyDefault; } catch (_) {}
            let zipFallback = String(data.zip_code || '').trim();
            if (!/^\d{5}$/.test(zipFallback)) {
                zipFallback = '33477';
                try { window._zipOnlyDefault = true; } catch (_) {}
            }
            data.__zipFallback = zipFallback;
            
            // Update header information
            document.getElementById('agentName').textContent = data.agent_name || 'Agent Name';
            document.getElementById('buyerName').textContent = `${data.first_name} ${data.last_name}` || 'Buyer Name';
            (function() {
                const city = String(data.home_city || data.city || '').trim();
                const state = String(data.home_state || data.state || '').trim();
                const zip = String(data.zip_code || '').trim();
                const isPalmBeach = /palm\s*beach/i.test(String(data.county || ''));
                let headerValue = 'ZIP Code';
                if (!isPalmBeach && zip) {
                    if (city && state) headerValue = `${city}, ${state.toUpperCase()} ${zip}`;
                    else if (state) headerValue = `${state.toUpperCase()} ${zip}`;
                    else if (city) headerValue = `${city} ${zip}`;
                    else headerValue = `ZIP ${zip}`;
                } else if (zip) {
                    headerValue = `ZIP ${zip}`;
                }
                document.getElementById('zipCode').textContent = headerValue;
            })();
            
            // Determine if property is out-of-state (non-Florida)
            try {
                const stateValue = String(data.home_state || '').trim().toLowerCase();
                window.isOutOfState = !(stateValue === 'fl' || stateValue === 'florida');
            } catch (_) { window.isOutOfState = false; }
            
            // Update Home Info map button UI based on state
            try {
                const mapButton = document.getElementById('mapButton');
                if (mapButton) {
                    if (window.isOutOfState) {
                        mapButton.style.opacity = '0.5';
                        mapButton.style.cursor = 'not-allowed';
                        mapButton.style.pointerEvents = 'none';
                        mapButton.title = 'Map is unavailable for out-of-state properties';
                    } else {
                        mapButton.style.opacity = '';
                        mapButton.style.cursor = 'pointer';
                        mapButton.style.pointerEvents = '';
                        mapButton.title = '';
                    }
                }
            } catch (_) {}
            
            // Charts - Skip overwriting chartsContent since it now contains FRED interface
            // Chart data is now handled by the FRED comparison interface in Area Charts section
            
            // Interest areas
            if (data.interest_areas && data.interest_areas.length > 0) {
                const areasHtml = data.interest_areas.map(area => `
                    <div class="info-item">
                        <div class="info-label">Interest ${area.interest_id}</div>
                        <div class="info-value">${area.city}, ${area.state}</div>
                    </div>
                `).join('');
                document.getElementById('interestAreasContent').innerHTML = `<div class="info-grid">${areasHtml}</div>`;
            }
            
            // Home Stats - Display property information
            displayHomeStats(data);
            initializeWealthMigrationSection(data);
            // Enable interactive lookup (prefill with current report values)
            setupHomeLookup(data);
            
            // FRED Charts - Load the charts after displaying the report
            loadFredCharts(data.report_id);
            setupNationalInfoToggles();

            // ZIP Insights: always show zipcode insights section
            try {
                const section = document.getElementById('county-insights-section');
                if (section) {
                    section.style.display = 'flex';
                    // Always initialize ZIP insights; backend supplies default when missing
                    initCountyInsights(data || {});
                }

                // Keep Development/Zone sections visibility unchanged
            } catch (_) {}
        }
        
        function displayHomeStats(data) {
            // Helpers to normalize casing for display
            const DIRECTIONALS = new Set(['N','S','E','W','NE','NW','SE','SW']);
            const ROMAN_NUMERALS = new Set(['I','II','III','IV','V','VI','VII','VIII','IX','X']);
            function capitalizeWord(word) {
                if (!word) return word;
                const raw = String(word);
                const alnum = raw.replace(/[^A-Za-z0-9]/g, '');
                if (alnum.length === 0) return raw; // punctuation-only
                if (/^\d+$/.test(alnum)) return raw; // numbers
                if (DIRECTIONALS.has(alnum.toUpperCase())) return alnum.toUpperCase();
                if (ROMAN_NUMERALS.has(alnum.toUpperCase())) return alnum.toUpperCase();
                const lower = raw.toLowerCase();
                return lower.replace(/([A-Za-zÀ-ÖØ-öø-ÿ])(\S*)/, (_m, a, b) => a.toUpperCase() + b);
            }
            function toTitleCaseSmart(str) {
                if (!str) return str;
                return String(str)
                    .split(' ')
                    .map(part => part.split('-').map(capitalizeWord).join('-'))
                    .join(' ');
            }
            // Format address with each component on separate lines
            let addressLines = [];
            
            // Address Line 1 (title case for display)
            if (data.address_line_1 && data.address_line_1.trim()) {
                addressLines.push(toTitleCaseSmart(data.address_line_1.trim()));
            }
            
            // Address Line 2 (if exists)
            if (data.address_line_2 && data.address_line_2.trim()) {
                addressLines.push(toTitleCaseSmart(data.address_line_2.trim()));
            }
            
            // City, State, Zip
            let cityStateZip = [];
            if (data.home_city) cityStateZip.push(toTitleCaseSmart(data.home_city));
            if (data.home_state) cityStateZip.push(data.home_state);
            if (data.zip_code) cityStateZip.push(data.zip_code);
            if (cityStateZip.length > 0) {
                addressLines.push(cityStateZip.join(', '));
            }
            
            // Development & Subdivision (avoid duplicate when identical)
            const devName = (data.development && data.development.trim()) ? toTitleCaseSmart(data.development.trim()) : '';
            const subName = (data.subdivision && data.subdivision.trim()) ? toTitleCaseSmart(data.subdivision.trim()) : '';
            if (devName) {
                addressLines.push(devName);
            }
            if (subName && subName.toLowerCase() !== devName.toLowerCase()) {
                addressLines.push(subName);
            }
            
            // Update property details with styled formatting
            const addressElement = document.getElementById('propertyAddress');
            if (addressLines.length > 0) {
                let styledAddress = '';
                addressLines.forEach((line, index) => {
                    // Determine line type based on content pattern rather than position
                    const isCityStateZip = line.includes(',') && /\d{5}/.test(line); // Contains comma and 5-digit zip
                    const isStreetAddress = index === 0 || (index === 1 && !isCityStateZip);
                    
                    if (isStreetAddress) {
                        // Street address lines - larger and bolder
                        styledAddress += `<div style="font-size: 18px; font-weight: 600; color: #2c3e50; margin-bottom: 4px; line-height: 1.3;">${line}</div>`;
                    } else if (isCityStateZip) {
                        // City, State, Zip line - medium weight
                        styledAddress += `<div style="font-size: 20px; font-weight: 500; color: #34495e; margin-bottom: 8px; line-height: 1.3;">${line}</div>`;
                    } else {
                        // Development/Subdivision - lighter styling with subtle separation
                        styledAddress += `<div style="font-size: 18px; font-weight: 400; color: #7f8c8d; margin-bottom: 3px; line-height: 1.4; font-style: italic;">${line}</div>`;
                    }
                });
                addressElement.innerHTML = styledAddress;
            } else {
                addressElement.innerHTML = `<div style="font-size: 16px; color: #95a5a6; font-style: italic;">Address information not available</div>`;
            }
            
            // Hide the development and subdivision elements since they're now in the address
            document.getElementById('propertyDevelopment').style.display = 'none';
            document.getElementById('propertySubdivision').style.display = 'none';

            // Gate PB-only sections (Development/Zone comparisons & parcels) to Palm Beach only
            try {
                const countyName = String(data.county || '').toLowerCase();
                const isPalmBeach = countyName.includes('palm beach');
                try { window.isPalmBeachCounty = isPalmBeach; } catch (_) {}
                const devSectionTitle = document.getElementById('dev-comp-title');
                const devControls = document.getElementById('dev-controls-section');
                const devChartSection = document.getElementById('dev-chart-section');
                if (!isPalmBeach) {
                    // Hide the entire Neighbourhood Charts section when not Palm Beach County
                    if (devSectionTitle) {
                        const sectionEl = devSectionTitle.closest('.section');
                        if (sectionEl) sectionEl.style.display = 'none';
                    }
                    if (devControls) devControls.style.display = 'none';
                    if (devChartSection) devChartSection.style.display = 'none';
                }
            } catch (_) {}
            
            // Enrich Home Stats via property lookup (address → parcel → tax fields)
            (async () => {
                try {
                    const params = new URLSearchParams();
                    const hasStreet = typeof data.address_line_1 === 'string' && data.address_line_1.trim().length >= 6;
                    if (hasStreet) params.set('address', data.address_line_1);
                    if (data.home_city) params.set('city', data.home_city);
                    if (data.zip_code) params.set('zip', data.zip_code);
                    if (data.development) params.set('development', data.development);
                    if (data.subdivision) params.set('subdivision', data.subdivision);
                    const query = params.toString();
                    // Require a street address for property-lookup; ZIP-only is not supported by backend
                    if (!hasStreet || (typeof window !== 'undefined' && window._zipOnlyDefault === true)) {
                        // Nothing to lookup; skip request
                        return;
                    }
                    const resp = await fetch(`${API_BASE}/property-lookup?${query}`);
                    if (resp.ok) {
                        const result = await resp.json();
                        if (result && result.success && Array.isArray(result.data) && result.data.length > 0) {
                            const best = result.data[0];
                            const container = document.getElementById('homeStatsContent');
                            if (container) {
                                const infoBlock = document.createElement('div');
                                infoBlock.style.marginTop = '12px';

                                // Helpers to format numeric values from tax table safely
                                const formatInt = (value) => {
                                    if (value === null || value === undefined) return 'N/A';
                                    const trimmed = String(value).trim();
                                    if (trimmed.length === 0) return 'N/A';
                                    const parsed = parseInt(trimmed, 10);
                                    return Number.isNaN(parsed) ? 'N/A' : String(parsed);
                                };

                                const formatQuantity = (value) => {
                                    if (value === null || value === undefined) return 'N/A';
                                    const trimmed = String(value).trim();
                                    if (trimmed.length === 0) return 'N/A';
                                    const parsed = parseInt(trimmed, 10);
                                    return Number.isNaN(parsed) ? 'N/A' : parsed.toLocaleString('en-US');
                                };

                                const formatCurrency0 = (value) => {
                                    if (value === null || value === undefined) return 'N/A';
                                    const cleaned = String(value).replace(/[^0-9.\-]/g, '');
                                    const num = Number(cleaned);
                                    return Number.isFinite(num)
                                        ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(num)
                                        : 'N/A';
                                };

                                const yearBuilt = formatInt(best.year_built);
                                const livingSqFt = formatQuantity(best.square_foot_living_area);
                                const bedrooms = formatInt(best.number_of_bedrooms);
                                const fullBaths = formatInt(best.number_of_full_bathrooms);
                                const halfBaths = formatInt(best.number_of_half_bathrooms);
                                const halfBathsHtml = (halfBaths !== 'N/A' && parseInt(halfBaths, 10) > 0)
                                    ? `<div><span style=\"color:#7f8c8d\">🚿 Half Bath:</span> <strong>${halfBaths}</strong></div>`
                                    : '';
                                const marketValue = formatCurrency0(best.total_market_value);

                                // Build address content to merge into one unified card
                                let addressHtml = addressLines.length > 0
                                    ? addressLines.map((line, idx) => {
                                        const isCityStateZip = line.includes(',') && /\d{5}/.test(line);
                                        const isPrimary = idx === 0 || (idx === 1 && !isCityStateZip);
                                        const style = isPrimary
                                            ? 'font-size:18px;font-weight:600;color:#2c3e50;margin-bottom:4px;line-height:1.3;'
                                            : (isCityStateZip
                                                ? 'font-size:20px;font-weight:500;color:#34495e;margin-bottom:6px;line-height:1.3;'
                                                : 'font-size:16px;font-weight:400;color:#7f8c8d;margin-bottom:3px;line-height:1.4;font-style:italic;');
                                        return `<div style="${style}">${line}</div>`;
                                    }).join('')
                                    : '<div style="font-size:16px;color:#95a5a6;font-style:italic;">Address information not available</div>';

                                // If development was not provided but inferred from lookup, reflect it in UI and globals
                                if ((!data.development || String(data.development).trim().length === 0) && best.development_name) {
                                    try { window._inferredDevelopment = best.development_name; } catch {}
                                    try { currentDevelopmentName = best.development_name; } catch {}
                                    try { setupChartButton(best.development_name); } catch {}
                                    const devLine = `<div style=\"font-size:16px;font-weight:400;color:#7f8c8d;margin-bottom:3px;line-height:1.4;font-style:italic;\">${best.development_name}</div>`;
                                    addressHtml = addressHtml + devLine;
                                }

                                infoBlock.innerHTML = `
                                    <div style="background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); border: 1px solid #e9ecef; border-radius: 10px; padding: 16px;">
                                        <div style="display:flex; align-items:flex-start; gap:10px; margin-bottom:12px;">
                                            <div style="font-size:20px; line-height:1;">📍</div>
                                            <div style="flex:1;">${addressHtml}</div>
                                        </div>
                                        <div style="height:1px; background:#e9ecef; margin:10px 0 14px 0;"></div>
                                        <div style="display: grid; grid-template-columns: repeat(2, minmax(160px, 1fr)); gap: 12px; align-items: center;">
                                            <div><span style=\"color:#7f8c8d\">🛏️ Bedrooms:</span> <strong>${bedrooms}</strong></div>
                                            <div><span style=\"color:#7f8c8d\">📐 Living SqFt:</span> <strong>${livingSqFt}</strong></div>
                                            <div><span style=\"color:#7f8c8d\">🛁 Bath:</span> <strong>${fullBaths}</strong></div>
                                            <div><span style=\"color:#7f8c8d\">🏗️ Year Built:</span> <strong>${yearBuilt}</strong></div>
                                            ${halfBathsHtml}
                                            <div><span style=\"color:#7f8c8d\">💲 Tax Value:</span> <strong>${marketValue}</strong></div>
                                        </div>
                                    </div>
                                `;

                                const leftPanel = container.firstElementChild;
                                if (leftPanel) {
                                    const buttonsRow = leftPanel.querySelector('#mapButton') ? leftPanel.querySelector('#mapButton').parentElement : null;
                                    if (buttonsRow) {
                                        leftPanel.insertBefore(infoBlock, buttonsRow);
                                    } else {
                                        leftPanel.appendChild(infoBlock);
                                    }
                                    // Hide the original separate address block to avoid duplication
                                    const addressBlock = leftPanel.querySelector('#propertyAddress');
                                    if (addressBlock) addressBlock.style.display = 'none';
                                }
                                // If no development was provided and we are in Palm Beach, try to auto-load stats from inferred development
                                if (window.isPalmBeachCounty !== false && (!data.development || String(data.development).trim().length === 0) && best.development_name) {
                                    try { await loadDevelopmentStats(best.development_name); } catch {}
                                } else if (window.isPalmBeachCounty === false && data.zip_code) {
                                    try { await loadZipStats(String(data.zip_code)); } catch {}
                                }
                                // For non-Palm Beach, also augment left-side Home Info details via RentCast property profile
                                if (window.isPalmBeachCounty === false) {
                                    try {
                                        const addrParts = [];
                                        if (hasStreet) addrParts.push(String(data.address_line_1).trim());
                                        if (data.home_city || data.home_state || data.zip_code) {
                                            const cityStateZip = [String(data.home_city || '').trim(), String(data.home_state || '').trim(), String(data.zip_code || '').trim()].filter(Boolean).join(', ');
                                            if (cityStateZip) addrParts.push(cityStateZip);
                                        }
                                        const fullAddress = addrParts.join(', ');
                                        // Require a true street address, not ZIP-only
                                        const hasTrueStreet = hasStreet && /\s/.test(String(data.address_line_1));
                                        if (hasTrueStreet && fullAddress.length >= 8) {
                                            const resp = await fetch(`${API_BASE}/property-profile?address=${encodeURIComponent(fullAddress)}`);
                                            const pr = await resp.json();
                                            if (resp.ok && pr && pr.success && pr.data) {
                                                const p = pr.data;
                                                const detailsCard = document.createElement('div');
                                                detailsCard.style.marginTop = '12px';
                                                const fmtQty = (v) => {
                                                    const n = Number(v);
                                                    return Number.isFinite(n) ? n.toLocaleString() : 'N/A';
                                                };
                                                const fmtCurr0 = (v) => {
                                                    const n = Number(v);
                                                    return Number.isFinite(n) ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(n) : 'N/A';
                                                };
                                                detailsCard.innerHTML = `
                                                    <div style="background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); border: 1px solid #e9ecef; border-radius: 10px; padding: 16px;">
                                                        <div style="display: grid; grid-template-columns: repeat(2, minmax(160px, 1fr)); gap: 12px; align-items: center;">
                                                            <div><span style=\"color:#7f8c8d\">🛏️ Bedrooms:</span> <strong>${fmtQty(p.bedrooms)}</strong></div>
                                                            <div><span style=\"color:#7f8c8d\">🛁 Bathrooms:</span> <strong>${fmtQty(p.bathrooms)}</strong></div>
                                                            <div><span style=\"color:#7f8c8d\">📐 Living SqFt:</span> <strong>${fmtQty(p.squareFootage)}</strong></div>
                                                            <div><span style=\"color:#7f8c8d\">📏 Lot Size:</span> <strong>${fmtQty(p.lotSize)}</strong></div>
                                                            <div><span style=\"color:#7f8c8d\">🏗️ Year Built:</span> <strong>${fmtQty(p.yearBuilt)}</strong></div>
                                                            <div><span style=\"color:#7f8c8d\">💲 Tax Assessment:</span> <strong>${fmtCurr0(p.taxAssessmentValue)}</strong></div>
                                                        </div>
                                                    </div>
                                                `;
                                                if (leftPanel) {
                                                    leftPanel.appendChild(detailsCard);
                                                }
                                            }
                                        }
                                    } catch (_) { /* ignore profile errors */ }
                                }
                            }
                        }
                    }
                } catch (lookupErr) {
                    console.warn('Property lookup failed:', lookupErr);
                }
            })();
            
            // Load development stats in Palm Beach, else load ZIP stats when available
            if (window.isPalmBeachCounty !== false) {
                if (data.development && data.development.trim()) {
                    loadDevelopmentStats(data.development.trim());
                }
            } else {
                const zipForStats = (typeof data.__zipFallback === 'string' && /^\d{5}$/.test(data.__zipFallback))
                    ? data.__zipFallback
                    : (typeof data.zip_code === 'string' ? data.zip_code.trim() : '');
                if (zipForStats && /^\d{5}$/.test(zipForStats)) {
                    loadZipStats(String(zipForStats));
                }
            }
            
            // Setup chart button click handler
            setupChartButton(data.development && data.development.trim() ? data.development.trim() : null);

            // For non-Palm Beach, augment Home Info with RentCast property profile regardless of county tax lookup result
            if (window.isPalmBeachCounty === false) {
                try { console.log('Non-PB: preparing RentCast profile fetch. isPalmBeachCounty=', window.isPalmBeachCounty); } catch (_) {}
                (async () => {
                    try {
                        const leftPanelHost = document.querySelector('#homeStatsContent > div:first-child');
                        if (!leftPanelHost) return;
                        // Avoid duplicate injection
                        if (leftPanelHost.querySelector('[data-rentcast-profile="1"]')) return;
                        const parts = [];
                        const hasStreet = typeof data.address_line_1 === 'string' && data.address_line_1.trim().length >= 6 && /\s/.test(String(data.address_line_1));
                        if (typeof window !== 'undefined' && window._zipOnlyDefault === true) return;
                        if (hasStreet) parts.push(String(data.address_line_1).trim());
                        const cityStateZip = [String(data.home_city || '').trim(), String(data.home_state || '').trim(), String(data.zip_code || '').trim()].filter(Boolean).join(', ');
                        if (hasStreet && cityStateZip) parts.push(cityStateZip);
                        const fullAddress = parts.join(', ');
                        try { console.log('Non-PB: fullAddress built for RentCast:', fullAddress); } catch (_) {}
                        if (!hasStreet || fullAddress.length < 8) return;
                        const endpoint = `${API_BASE}/property-profile?address=${encodeURIComponent(fullAddress)}`;
                        try { console.log('Non-PB: fetching RentCast profile:', endpoint); } catch (_) {}
                        const resp = await fetch(endpoint);
                        const pr = await resp.json();
                        try { console.log('Non-PB: RentCast profile response ok=', resp.ok, 'success=', pr && pr.success); } catch (_) {}
                        if (!resp.ok || !pr || !pr.success || !pr.data) return;
                        const p = pr.data;
                        const detailsCard = document.createElement('div');
                        detailsCard.setAttribute('data-rentcast-profile', '1');
                        detailsCard.style.marginTop = '12px';
                        const fmtQty = (v) => {
                            const n = Number(v);
                            return Number.isFinite(n) ? n.toLocaleString() : 'N/A';
                        };
                        const fmtCurr0 = (v) => {
                            const n = Number(v);
                            return Number.isFinite(n) ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(n) : 'N/A';
                        };
                        detailsCard.innerHTML = `
                            <div style="background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); border: 1px solid #e9ecef; border-radius: 10px; padding: 16px;">
                                <div style="display: grid; grid-template-columns: repeat(2, minmax(160px, 1fr)); gap: 12px; align-items: center;">
                                    <div><span style=\"color:#7f8c8d\">🛏️ Bedrooms:</span> <strong>${fmtQty(p.bedrooms)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">🛁 Bathrooms:</span> <strong>${fmtQty(p.bathrooms)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">📐 Living SqFt:</span> <strong>${fmtQty(p.squareFootage)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">📏 Lot Size:</span> <strong>${fmtQty(p.lotSize)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">🏗️ Year Built:</span> <strong>${fmtQty(p.yearBuilt)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">💲 Tax Assessment:</span> <strong>${fmtCurr0(p.taxAssessmentValue)}</strong></div>
                                </div>
                            </div>
                        `;
                        const mapButton = document.getElementById('mapButton');
                        const buttonsRow = mapButton ? mapButton.parentElement : null;
                        if (buttonsRow && buttonsRow.parentElement === leftPanelHost) {
                            leftPanelHost.insertBefore(detailsCard, buttonsRow);
                        } else {
                            leftPanelHost.appendChild(detailsCard);
                        }
                    } catch (_) {}
                })();
            }
        }
        // Interactive Home Lookup using RentCast proxy endpoints
        function setupHomeLookup(initialData) {
            try {
                const form = document.getElementById('homeLookupForm');
                if (!form) return;
                const inputAddress = document.getElementById('hl_address');
                const inputCity = document.getElementById('hl_city');
                const inputState = document.getElementById('hl_state');
                const inputZip = document.getElementById('hl_zip');
                const resultsHost = document.getElementById('homeLookupResults');
                // Prefill from report data when available
                if (initialData) {
                    if (initialData.address_line_1) inputAddress.value = String(initialData.address_line_1);
                    if (initialData.home_city) inputCity.value = String(initialData.home_city);
                    if (initialData.home_state) inputState.value = String(initialData.home_state);
                    if (initialData.zip_code) inputZip.value = String(initialData.zip_code);
                }
                form.addEventListener('submit', async (ev) => {
                    ev.preventDefault();
                    const addr = String(inputAddress.value || '').trim();
                    const city = String(inputCity.value || '').trim();
                    const state = String(inputState.value || '').trim();
                    const zip = String(inputZip.value || '').trim();
                    // Update the address display immediately
                    const lines = [];
                    if (addr) lines.push(addr);
                    const csz = [city, state, zip].filter(Boolean).join(', ');
                    if (csz) lines.push(csz);
                    const addressElement = document.getElementById('propertyAddress');
                    if (addressElement) {
                        addressElement.innerHTML = lines.length > 0
                            ? lines.map((line, idx) => {
                                const isCSZ = /\d{5}$/.test(line) || line.includes(',');
                                const isPrimary = idx === 0 && !isCSZ;
                                const style = isPrimary
                                    ? 'font-size:18px;font-weight:600;color:#2c3e50;margin-bottom:4px;line-height:1.3;'
                                    : (isCSZ
                                        ? 'font-size:20px;font-weight:500;color:#34495e;margin-bottom:6px;line-height:1.3;'
                                        : 'font-size:16px;font-weight:400;color:#7f8c8d;margin-bottom:3px;line-height:1.4;font-style:italic;');
                                return `<div style="${style}">${line}</div>`;
                              }).join('')
                            : '<div style="font-size:16px;color:#95a5a6;font-style:italic;">Enter an address to view details</div>';
                    }
                    // Clear previous results and show a small loader
                    if (resultsHost) {
                        resultsHost.innerHTML = `
                            <div style="display:flex;align-items:center;gap:10px;color:#7f8c8d;">
                                <div style="border:3px solid #f3f3f3;border-top:3px solid #3498db;border-radius:50%;width:18px;height:18px;animation:spin 2s linear infinite;"></div>
                                <span>Fetching property details…</span>
                            </div>`;
                    }
                    // If ZIP provided, refresh right-side stats
                    if (zip) {
                        try { await loadZipStats(zip); } catch (_) { /* ignore */ }
                    }
                    // Only call RentCast property profile when we have a plausible street address
                    const hasStreet = addr && /\s/.test(addr) && addr.length >= 6;
                    const fullAddress = [addr, [city, state, zip].filter(Boolean).join(', ')].filter(Boolean).join(', ');
                    if (!hasStreet || fullAddress.length < 8) {
                        if (resultsHost) resultsHost.innerHTML = '';
                        return;
                    }
                    try {
                        const endpoint = `${API_BASE}/property-profile?address=${encodeURIComponent(fullAddress)}`;
                        const resp = await fetch(endpoint);
                        const pr = await resp.json();
                        if (!resp.ok || !pr || !pr.success || !pr.data) {
                            if (resultsHost) resultsHost.innerHTML = '';
                            return;
                        }
                        const p = pr.data;
                        const fmtQty = (v) => {
                            const n = Number(v);
                            return Number.isFinite(n) ? n.toLocaleString() : 'N/A';
                        };
                        const fmtCurr0 = (v) => {
                            const n = Number(v);
                            return Number.isFinite(n)
                                ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(n)
                                : 'N/A';
                        };
                        const card = `
                            <div style="background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); border: 1px solid #e9ecef; border-radius: 10px; padding: 16px;">
                                <div style="display: grid; grid-template-columns: repeat(2, minmax(160px, 1fr)); gap: 12px; align-items: center;">
                                    <div><span style=\"color:#7f8c8d\">🛏️ Bedrooms:</span> <strong>${fmtQty(p.bedrooms)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">🛁 Bathrooms:</span> <strong>${fmtQty(p.bathrooms)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">📐 Living SqFt:</span> <strong>${fmtQty(p.squareFootage)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">📏 Lot Size:</span> <strong>${fmtQty(p.lotSize)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">🏗️ Year Built:</span> <strong>${fmtQty(p.yearBuilt)}</strong></div>
                                    <div><span style=\"color:#7f8c8d\">💲 Tax Assessment:</span> <strong>${fmtCurr0(p.taxAssessmentValue)}</strong></div>
                                </div>
                            </div>`;
                        if (resultsHost) resultsHost.innerHTML = card;
                    } catch (_) {
                        if (resultsHost) resultsHost.innerHTML = '';
                    }
                });
            } catch (_) { /* no-op */ }
        }
        
        // Function to setup chart button click handler (idempotent and re-runnable)
        function setupChartButton(developmentName) {
            const chartButton = document.getElementById('chartButton');
            if (!chartButton) return;
            const hasDev = typeof developmentName === 'string' && developmentName.trim().length > 0;
            if (hasDev) {
                const dev = developmentName.trim();
                // Enable styles
                chartButton.style.opacity = '';
                chartButton.style.cursor = 'pointer';
                chartButton.title = '';
                chartButton.style.backgroundColor = '#ffffff';
                chartButton.style.borderColor = '#dee2e6';
                // Replace handlers idempotently
                chartButton.onclick = function() { showChartOverlay(dev); };
                chartButton.onmouseenter = function() {
                    this.style.backgroundColor = '#f8f9fa';
                    this.style.borderColor = '#27ae60';
                    this.style.transform = 'translateY(-1px)';
                };
                chartButton.onmouseleave = function() {
                    this.style.backgroundColor = '#ffffff';
                    this.style.borderColor = '#dee2e6';
                    this.style.transform = 'translateY(0)';
                };
            } else {
                // Disable and remove handlers
                chartButton.onclick = null;
                chartButton.onmouseenter = null;
                chartButton.onmouseleave = null;
                chartButton.style.opacity = '0.5';
                chartButton.style.cursor = 'not-allowed';
                chartButton.title = 'Chart data not available for this property';
            }
        }
        // Function to show chart overlay
        async function showChartOverlay(entityName, typeHint) {
            const overlay = document.getElementById('chartOverlay');
            const title = document.getElementById('chartOverlayTitle');
            const content = document.getElementById('chartOverlayContent');
            
            // Show overlay
            overlay.style.display = 'flex';
            title.textContent = `${entityName} - Sales Analysis`;
            
            // Show loading state
            content.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite; margin: 0 auto 20px;"></div>
                    <p style="color: #7f8c8d; font-size: 16px;">Loading sales chart data...</p>
                </div>
            `;
            
            try {
                // Fetch chart data (zones currently use same endpoint if supported; adjust if separate)
                // Fetch appropriate chart endpoint based on type
                const endpoint = (typeHint === 'zone')
                    ? `${API_BASE}/zone-chart/${encodeURIComponent(entityName)}`
                    : `${API_BASE}/development-chart/${encodeURIComponent(entityName)}`;
                const response = await fetch(endpoint);
                const result = await response.json();
                
                if (response.ok && result.success) {
                    displayChartData(result.data);
                } else {
                    throw new Error(result.error || 'Failed to load chart data');
                }
            } catch (error) {
                console.error('Error loading chart data:', error);
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div style="color: #e74c3c; font-size: 48px; margin-bottom: 20px;">📊</div>
                        <h3 style="color: #2c3e50; margin-bottom: 10px;">Chart Data Unavailable</h3>
                        <p style="color: #7f8c8d;">Unable to load sales data for this development.</p>
                    </div>
                `;
            }
        }
        
        // Function to display chart data
        function displayChartData(data) {
            const content = document.getElementById('chartOverlayContent');
            const chartData = data.chartData;
            
            if (!chartData || chartData.length === 0) {
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div style="color: #f39c12; font-size: 48px; margin-bottom: 20px;">📈</div>
                        <h3 style="color: #2c3e50; margin-bottom: 10px;">No Sales Data</h3>
                        <p style="color: #7f8c8d;">No recorded sales found for ${data.developmentName} in the last 10 years.</p>
                    </div>
                `;
                return;
            }
            
            // Create chart HTML
            let chartHtml = `
                <div style="margin-bottom: 30px;">
                    <h3 style="text-align: center; color: #2c3e50; margin-bottom: 20px;">Annual Sales Summary - Last 10 Years</h3>
                    <div style="display: flex; gap: 30px;">
                        <!-- Sales Count Chart -->
                        <div style="flex: 1;">
                            <h4 style="text-align: center; color: #34495e; margin-bottom: 15px;">Number of Sales per Year</h4>
                            <div style="height: 300px; position: relative;">
                                <canvas id="salesCountChart" style="width: 100%; height: 100%;"></canvas>
                            </div>
                        </div>
                        
                        <!-- Price Chart -->
                        <div style="flex: 1;">
                            <h4 style="text-align: center; color: #34495e; margin-bottom: 10px; display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap;">
                                <span style="font-weight: 500;">Sale Price per Year</span>
                                <label for="priceMetricSelect" style="font-weight: 500; color: #4b5563; display: flex; align-items: center; gap: 6px;">
                                    <span></span>
                                    <select id="priceMetricSelect" style="padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 15px; color: #1f2937; background: #ffffff; min-width: 160px; cursor: pointer;">
                                    <option value="avg" selected>Average</option>
                                    <option value="median">Median</option>
                                    </select>
                                </label>
                            </h4>
                            <div style="height: 300px; position: relative;">
                                <canvas id="avgPriceChart" style="width: 100%; height: 100%;"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Data Table -->
                <div style="margin-top: 20px;">
                    <h4 style="color: #2c3e50; margin-bottom: 15px;">Detailed Sales Data</h4>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd;">
                            <thead>
                                <tr style="background: #f8f9fa;">
                                    <th style="padding: 12px; text-align: left; border: 1px solid #ddd; color: #2c3e50;">Year</th>
                                    <th style="padding: 12px; text-align: right; border: 1px solid #ddd; color: #2c3e50;">Sales Count</th>
                                    <th style="padding: 12px; text-align: right; border: 1px solid #ddd; color: #2c3e50;">Average Price</th>
                                    <th style="padding: 12px; text-align: right; border: 1px solid #ddd; color: #2c3e50;">Median Price</th>
                                    <th style="padding: 12px; text-align: right; border: 1px solid #ddd; color: #2c3e50;">Price Range</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            // Sort chartData by year in descending order (newest first)
            const sortedChartData = [...chartData].sort((a, b) => parseInt(b.sale_year) - parseInt(a.sale_year));
            
            sortedChartData.forEach(row => {
                const avgPrice = row.avg_price ? `$${parseInt(row.avg_price).toLocaleString()}` : 'N/A';
                const medianPrice = row.median_price ? `$${parseInt(row.median_price).toLocaleString()}` : 'N/A';
                const minPrice = row.min_price ? `$${parseInt(row.min_price).toLocaleString()}` : 'N/A';
                const maxPrice = row.max_price ? `$${parseInt(row.max_price).toLocaleString()}` : 'N/A';
                const priceRange = (row.min_price && row.max_price) ? `${minPrice} - ${maxPrice}` : 'N/A';
                
                chartHtml += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd; font-weight: 500;">${row.sale_year}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${row.sales_count}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${avgPrice}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${medianPrice}</td>
                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right; font-size: 12px;">${priceRange}</td>
                    </tr>
                `;
            });
            
            chartHtml += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            content.innerHTML = chartHtml;
            
            // Render Chart.js charts
            const priceMetricOptions = {
                avg: { field: 'avg_price', label: 'Average Sale Price', color: '#27ae60' },
                median: { field: 'median_price', label: 'Median Sale Price', color: '#8e44ad' }
            };

            function renderPriceChart(metricKey) {
                const config = priceMetricOptions[metricKey] || priceMetricOptions.avg;
                renderPopupChart('avgPriceChart', chartData, config.field, config.color, config.label);
            }

            setTimeout(() => {
                renderPopupChart('salesCountChart', chartData, 'sales_count', '#3498db', 'Number of Sales');
                const selectEl = document.getElementById('priceMetricSelect');
                renderPriceChart(selectEl?.value || 'avg');
                if (selectEl) {
                    selectEl.addEventListener('change', (event) => {
                        renderPriceChart(event.target.value);
                    }, { once: false });
                }
            }, 100);
        }
        // Function to render simple bar chart
        function renderBarChart(data, valueField, color, prefix = '') {
            if (!data || data.length === 0) return '<p>No data available</p>';
            
            const maxValue = Math.max(...data.map(d => parseFloat(d[valueField]) || 0));
            const minValue = Math.min(...data.map(d => parseFloat(d[valueField]) || 0));
            
            let chartHtml = `
                <div style="display: flex; align-items: end; height: 100%; gap: 8px; padding: 20px 10px 30px;">
            `;
            
            data.forEach(item => {
                const value = parseFloat(item[valueField]) || 0;
                const height = maxValue > 0 ? (value / maxValue) * 200 : 0;
                const displayValue = valueField === 'avg_price' ? 
                    `${prefix}${Math.round(value).toLocaleString()}` : 
                    `${value}${prefix}`;
                
                chartHtml += `
                    <div style="flex: 1; display: flex; flex-direction: column; align-items: center;">
                        <div style="position: relative; margin-bottom: 8px;">
                            <div style="
                                width: 100%; 
                                height: ${height}px; 
                                background: ${color}; 
                                border-radius: 4px 4px 0 0;
                                min-height: 2px;
                                position: relative;
                                display: flex;
                                align-items: end;
                                justify-content: center;
                                padding-bottom: 5px;
                            ">
                                <span style="
                                    color: white; 
                                    font-size: 10px; 
                                    font-weight: bold;
                                    text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
                                    writing-mode: vertical-rl;
                                    text-orientation: mixed;
                                ">${displayValue}</span>
                            </div>
                        </div>
                        <div style="font-size: 12px; font-weight: 500; color: #2c3e50;">${item.sale_year}</div>
                    </div>
                `;
            });
            
            chartHtml += `</div>`;
            return chartHtml;
        }
        
        // Function to render popup charts using Chart.js
        function renderPopupChart(canvasId, data, valueField, color, label) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas ${canvasId} not found`);
                return;
            }
            
            // Destroy existing chart instance
            if (canvasId === 'salesCountChart' && salesCountChartInstance) {
                salesCountChartInstance.destroy();
            } else if (canvasId === 'avgPriceChart' && avgPriceChartInstance) {
                avgPriceChartInstance.destroy();
            }
            
            // Prepare data for Chart.js
            const chartData = data.map(item => ({
                x: item.sale_year.toString(),
                y: parseFloat(item[valueField]) || 0
            }));
            
            const ctx = canvas.getContext('2d');
            
            // Determine if this is a price chart for formatting
            const isPrice = /price/i.test(valueField);
            
            // Create Chart.js configuration
            const config = {
                type: 'line',
                data: {
                    datasets: [{
                        label: label,
                        data: chartData,
                        backgroundColor: color + '20', // 20% opacity for fill
                        borderColor: color,
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointHoverBackgroundColor: color,
                        pointHoverBorderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { left: 16, right: 16, top: 8, bottom: 12 } },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: function(tooltipItems) {
                                    return `Year ${tooltipItems[0].label}`;
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (isPrice) {
                                        return `${label}: $${Math.round(value).toLocaleString()}`;
                                    } else {
                                        return `${label}: ${value}`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            title: {
                                display: true,
                                text: 'Year',
                                color: '#2c3e50',
                                font: {
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: '#2c3e50',
                                font: {
                                    weight: '500'
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: label,
                                color: '#2c3e50',
                                font: {
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: '#f0f0f0'
                            },
                            ticks: {
                                color: '#666',
                                callback: function(value) {
                                    if (isPrice) {
                                        return '$' + Math.round(value).toLocaleString();
                                    } else {
                                        return value;
                                    }
                                }
                            }
                        }
                    },
                    animation: {
                        duration: 800,
                        easing: 'easeOutQuart'
                    }
                }
            };
            
            // Create the chart and store the instance
            const newChart = new Chart(ctx, config);
            
            if (canvasId === 'salesCountChart') {
                salesCountChartInstance = newChart;
            } else if (canvasId === 'avgPriceChart') {
                avgPriceChartInstance = newChart;
            }
        }
        
        // Function to close chart overlay and clean up chart instances
        function closeChartOverlay() {
            const overlay = document.getElementById('chartOverlay');
            overlay.style.display = 'none';
            
            // Destroy chart instances to free memory
            if (salesCountChartInstance) {
                salesCountChartInstance.destroy();
                salesCountChartInstance = null;
            }
            if (avgPriceChartInstance) {
                avgPriceChartInstance.destroy();
                avgPriceChartInstance = null;
            }
        }
        
        // Setup chart overlay close handlers
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('chartOverlay');
            const closeButton = document.getElementById('closeChartOverlay');
            
            // Close overlay when clicking close button
            closeButton.addEventListener('click', () => {
                closeChartOverlay();
            });
            
            // Close overlay when clicking outside the content
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeChartOverlay();
                }
            });
            
            // Close overlay with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && overlay.style.display === 'flex') {
                    closeChartOverlay();
                }
            });
            
            // Initialize development actions popup
            initializeDevelopmentActionsPopup();
        });
        // Initialize development actions popup functionality
        function initializeDevelopmentActionsPopup() {
            const popup = document.getElementById('developmentActionsPopup');
            
            // Close popup when clicking outside
            document.addEventListener('click', function(e) {
                if (__suppressNextDocumentClick) {
                    // Skip one document click that originated from legend click
                    __suppressNextDocumentClick = false;
                    return;
                }
                if (popup && popup.style.display !== 'none' && !popup.contains(e.target)) {
                    // Check if the click was on the chart legend (which should open the popup)
                    const isLegendClick = e.target.closest('.chartjs-legend') || 
                                         e.target.closest('canvas') || 
                                         e.target.tagName === 'CANVAS';
                    
                    if (!isLegendClick) {
                        hideDevelopmentActionsPopup();
                    }
                }
            });
            
            // Close popup with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && popup && popup.style.display !== 'none') {
                    hideDevelopmentActionsPopup();
                }
            });
        }
        
        // Function to load development statistics
        async function loadDevelopmentStats(developmentName) {
            try {
                console.log('Loading stats for development:', developmentName);
                
                // Show loading state in stats section
                const statsSection = document.querySelector('#homeStatsContent > div:last-child');
                if (statsSection) {
                    statsSection.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; min-height: 150px;">
                            <div style="text-align: center;">
                                <div style="border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 2s linear infinite; margin: 0 auto 15px;"></div>
                                <p style="margin: 0; color: #7f8c8d; font-size: 14px;">Loading ${developmentName} statistics...</p>
                            </div>
                        </div>
                    `;
                }
                
                const response = await fetch(`${API_BASE}/development-stats/${encodeURIComponent(developmentName)}`);
                const result = await response.json();
                
                if (response.ok && result.success) {
                    displayDevelopmentStats(result.data);
                } else {
                    console.error('Error loading development stats:', result.error);
                    displayStatsError('Unable to load development statistics');
                }
            } catch (error) {
                console.error('Error fetching development stats:', error);
                displayStatsError('Error loading statistics');
            }
        }
        
        // Function to display development statistics
        function displayDevelopmentStats(stats) {
            const statsSection = document.querySelector('#homeStatsContent > div:last-child');
            if (!statsSection) return;
            
            // Format large numbers for display
            const formatPrice = (price) => {
                if (!price || price === 0) return 'N/A';
                if (price >= 1000000) {
                    return `$${(price / 1000000).toFixed(1)}M`;
                } else if (price >= 1000) {
                    return `$${(price / 1000).toFixed(0)}K`;
                } else {
                    return `$${price.toLocaleString()}`;
                }
            };
            
            statsSection.innerHTML = `
                <div style="padding: 20px;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: #2c3e50; font-size: 22px; font-weight: 600; margin-bottom: 5px;">${stats.developmentName}</h3>
                        <div style="width: 60px; height: 2px; background: linear-gradient(90deg, #3498db, #27ae60); margin: 8px auto;"></div>
                        <p style="margin: 0; color: #7f8c8d; font-size: 16px; text-transform: uppercase; letter-spacing: 1px;">Development Statistics</p>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 18px;">
                        <!-- Left Column -->
                        <div>
                            <div style="margin-bottom: 8px;">
                                <strong>Parcels in Development:</strong> <span style="color: #2c3e50;">${stats.totalProperties}</span>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <strong>Active:</strong> <span style="color: #e74c3c;">${stats.activeListings}</span>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <strong>Active Under Contract:</strong> <span style="color: #f39c12;">${stats.underContract}</span>
                            </div>
                            ${stats.pending > 0 ? `<div style="margin-bottom: 8px;"><strong>Pending:</strong> <span style="color: #8e44ad;">${stats.pending}</span></div>` : ''}
                            <div style="margin-bottom: 8px;">
                                <strong>Closed (&lt; 3 Mos.):</strong> <span style="color: #27ae60;">${stats.closedLast3Months}</span>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <strong>Closed (&lt; 12 Mos.):</strong> <span style="color: #27ae60;">${stats.closedLast12Months}</span>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <strong>Active %:</strong> <span style="color: #2c3e50;">${stats.activePercentage}%</span>
                            </div>
                        </div>
                        
                        <!-- Right Column -->
                        <div>
                            <div style="margin-bottom: 12px;">
                                <strong>MLS Median Sale Price (YTD):</strong>
                            </div>
                            ${Object.keys(stats.medianPrices).length > 0 ? 
                                Object.entries(stats.medianPrices)
                                    .sort(([a], [b]) => parseInt(a) - parseInt(b))
                                    .map(([year, price]) => {
                                        const count = stats.saleCounts[year] || 0;
                                        return `<div style="margin-bottom: 6px; margin-left: 10px;">
                                            <strong>${year}:</strong> <span style="color: ${year === '2025' ? '#3498db' : '#2c3e50'};">${formatPrice(price)} (${count})</span>
                                        </div>`;
                                    }).join('') 
                                : '<div style="margin-left: 10px; color: #95a5a6; font-style: italic;">No recent sales data</div>'
                            }
                            
                            <div style="margin-top: 15px;">
                                <div style="margin-bottom: 6px;">
                                    <strong>Months of Inventory (3mo):</strong> <span style="color: #8e44ad;">${stats.inventoryMonths.threeMonth}</span>
                                </div>
                                <div style="margin-bottom: 6px;">
                                    <strong>Months of Inventory (12mo):</strong> <span style="color: #8e44ad;">${stats.inventoryMonths.twelveMonth}</span>
                                </div>
                            </div>
                            
                            ${stats.avgDaysOnMarket > 0 ? `
                            <div style="margin-top: 10px;">
                                <strong>Avg DOM (Active):</strong> <span style="color: #34495e;">${stats.avgDaysOnMarket} days</span>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Function to load ZIP-level statistics (fallback outside Palm Beach)
        async function loadZipStats(zipCode) {
            try {
                const statsSection = document.querySelector('#homeStatsContent > div:last-child');
                if (statsSection) {
                    statsSection.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; min-height: 150px;">
                            <div style="text-align: center;">
                                <div style="border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 2s linear infinite; margin: 0 auto 15px;"></div>
                                <p style="margin: 0; color: #7f8c8d; font-size: 14px;">Loading ZIP ${zipCode} market statistics...</p>
                            </div>
                        </div>
                    `;
                }
                // Use RentCast proxy endpoint (no county fallback for Home Info panel)
                const respLatest = await fetch(`${API_BASE}/zip-market?zip=${encodeURIComponent(String(zipCode))}`);
                const latestResp = await respLatest.json();
                if (!respLatest.ok || !latestResp.success || !latestResp.data) {
                    throw new Error(latestResp.error || 'No ZIP market data');
                }
                const latest = latestResp.data;
                let metaCity = '';
                let metaState = '';
                try {
                    const metaResp = await fetch(`${API_BASE}/zip-latest?zip=${encodeURIComponent(String(zipCode))}`);
                    if (metaResp.ok) {
                        const metaJson = await metaResp.json();
                        if (metaJson && metaJson.success && metaJson.data) {
                            metaCity = String(metaJson.data.city || '').trim();
                            metaState = String(metaJson.data.state_id || '').trim();
                        }
                    }
                } catch (_) {}
                // Fallback to zipcity lookup if needed
                if ((!metaCity || !metaState)) {
                    try {
                        const zcUrl = new URL(`${API_BASE}/zipcity/by-zip`, window.location.origin);
                        zcUrl.searchParams.set('zip', String(zipCode));
                        const zcResp = await fetch(zcUrl.toString().replace(window.location.origin, ''));
                        if (zcResp.ok) {
                            const zcJson = await zcResp.json();
                            const row = Array.isArray(zcJson?.data) ? zcJson.data[0] : null;
                            if (row) {
                                if (!metaCity) metaCity = String(row.city || '').trim();
                                if (!metaState) metaState = String(row.state_id || '').trim();
                            }
                        }
                    } catch (_) {}
                }
                const zipStats = {
                    zip5: String(zipCode),
                    city: metaCity,
                    state_id: metaState,
                    median_listing_price: (Number(latest.medianPrice) || null),
                    median_days_on_market: Number.isFinite(Number(latest.medianDaysOnMarket)) ? Math.max(0, Math.round(Number(latest.medianDaysOnMarket))) : null,
                    new_listing_count: Math.max(0, Math.floor(Number(latest.newListings) || 0)),
                    median_listing_price_per_sqft: (Number(latest.medianPricePerSquareFoot) || null),
                    total_listing_count: Math.max(0, Math.floor(Number(latest.totalListings) || 0))
                };
                displayZipStats(zipStats);
            } catch (error) {
                console.error('Error loading ZIP stats:', error);
                displayStatsError('Unable to load ZIP market statistics');
            }
        }

        // Function to display ZIP-level statistics
        function displayZipStats(stats) {
            const statsSection = document.querySelector('#homeStatsContent > div:last-child');
            if (!statsSection) return;
            const formatPrice = (price) => {
                if (price === null || price === undefined || Number(price) === 0) return 'N/A';
                const num = Number(price);
                if (!Number.isFinite(num)) return 'N/A';
                if (num >= 1000000) return `$${(num / 1000000).toFixed(1)}M`;
                if (num >= 1000) return `$${(num / 1000).toFixed(0)}K`;
                return `$${num.toLocaleString()}`;
            };
            const __city = String(stats.city || '').trim();
            const __state = String(stats.state_id || '').trim();
            const __titleGeo = (__city || __state)
                ? `${__city}${__city && __state ? ', ' : ''}${__state ? __state.toUpperCase() : ''} ${stats.zip5}`
                : `ZIP ${stats.zip5}`;
            statsSection.innerHTML = `
                <div style="padding: 20px; box-sizing: border-box;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: #2c3e50; font-size: 22px; font-weight: 600; margin-bottom: 5px;">${__titleGeo}</h3>
                        <div style="width: 60px; height: 2px; background: linear-gradient(90deg, #3498db, #27ae60); margin: 8px auto;"></div>
                        <p style="margin: 0; color: #7f8c8d; font-size: 16px; text-transform: uppercase; letter-spacing: 1px;">Market Statistics</p>
                    </div>
                    <div style="display: flex; gap: 24px; font-size: 18px; align-items: flex-start; justify-content: stretch; margin: 0;">
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 8px; margin: 0;">
                            <div><strong>New Listings (mo):</strong> <span style="color: #f39c12;">${stats.new_listing_count}</span></div>
                            <div><strong>Total Listings:</strong> <span style="color: #2c3e50;">${stats.total_listing_count}</span></div>
                        </div>
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 8px; margin: 0;">
                            <div><strong>Median Listing Price:</strong> <span style="color:#2c3e50;">${formatPrice(stats.median_listing_price)}</span></div>
                            <div><strong>Median Price per SqFt:</strong> <span style="color:#2c3e50;">${Number.isFinite(Number(stats.median_listing_price_per_sqft)) ? `$${Number(stats.median_listing_price_per_sqft).toFixed(0).toLocaleString?.() || Number(stats.median_listing_price_per_sqft).toLocaleString()}` : 'N/A'}</span></div>
                            <div><strong>Median Days on Market:</strong> <span style="color:#34495e;">${Number.isFinite(Number(stats.median_days_on_market)) ? `${Number(stats.median_days_on_market)} days` : 'N/A'}</span></div>
                        </div>
                    </div>
                </div>
            `;
        }

        function normalizeCountyLabel(value) {
            return String(value || '')
                .toLowerCase()
                .replace(/county$/i, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function determineStateForWealthMigration(reportData) {
            if (!reportData) {
                return DEFAULT_WEALTH_MIGRATION_STATE;
            }
            const candidates = [
                reportData.home_state,
                reportData.state,
                reportData.county_state,
                reportData.zip_state
            ];
            for (const candidate of candidates) {
                if (!candidate) continue;
                const trimmed = String(candidate).trim();
                if (!trimmed) continue;
                if (trimmed.length === 2) {
                    return STATE_ABBR_TO_NAME[trimmed.toUpperCase()] || trimmed.toUpperCase();
                }
                return trimmed;
            }
            return DEFAULT_WEALTH_MIGRATION_STATE;
        }

        async function loadWealthMigrationStates() {
            try {
                const response = await fetch(`${API_BASE}/states`);
                const payload = await response.json();
                if (!response.ok || !payload.success) {
                    throw new Error(payload.error || 'Unable to load states');
                }
                const states = Array.isArray(payload.data) ? payload.data : [];
                wealthMigrationStateOptions = states
                    .map(entry => ({
                        name: entry.stateName || entry.state || entry.State || '',
                        fips: String(entry.stateFips || entry.fips || entry.FipsCode || '').padStart(2, '0')
                    }))
                    .filter(entry => entry.name && /^\d{2}$/.test(entry.fips))
                    .sort((a, b) => a.name.localeCompare(b.name));
                wealthMigrationStateLookup = new Map(
                    wealthMigrationStateOptions.map(entry => [entry.fips, entry.name])
                );
                return wealthMigrationStateOptions;
            } catch (error) {
                console.error('Wealth migration states load error:', error);
                wealthMigrationStateOptions = [];
                wealthMigrationStateLookup = new Map();
                return [];
            }
        }

        function resolveWealthMigrationStateOption(preferredName) {
            if (!wealthMigrationStateOptions.length) {
                return null;
            }
            const normalizedName = String(preferredName || '').trim().toLowerCase();
            if (normalizedName) {
                const match = wealthMigrationStateOptions.find(
                    option => option.name.toLowerCase() === normalizedName
                );
                if (match) {
                    return match;
                }
            }
            return wealthMigrationStateOptions.find(option => option.name === DEFAULT_WEALTH_MIGRATION_STATE)
                || wealthMigrationStateOptions[0];
        }

        async function setupWealthMigrationSelectors(reportData) {
            const stateSelect = document.getElementById('wealthMigrationStateSelect');
            const countySelect = document.getElementById('wealthMigrationCountySelect');
            if (!stateSelect || !countySelect) return;

            stateSelect.innerHTML = '<option value="">Loading states...</option>';
            const states = await loadWealthMigrationStates();
            if (!states.length) {
                stateSelect.innerHTML = '<option value="">States unavailable</option>';
                countySelect.innerHTML = '<option value="">Counties unavailable</option>';
                showWealthMigrationFallback('Wealth migration controls are unavailable.');
                return;
            }

            const preferredStateName = determineStateForWealthMigration(reportData);
            const defaultStateOption = resolveWealthMigrationStateOption(preferredStateName);

            stateSelect.innerHTML = states.map(option => `
                <option value="${option.fips}">${option.name}</option>
            `).join('');
            stateSelect.value = defaultStateOption?.fips || states[0].fips;
            wealthMigrationStateFips = stateSelect.value;
            wealthMigrationState = wealthMigrationStateLookup.get(wealthMigrationStateFips) || DEFAULT_WEALTH_MIGRATION_STATE;

            stateSelect.addEventListener('change', async (event) => {
                const selectedFips = event.target.value;
                wealthMigrationStateFips = selectedFips;
                wealthMigrationState = wealthMigrationStateLookup.get(selectedFips) || DEFAULT_WEALTH_MIGRATION_STATE;
                await loadWealthMigrationCounties(selectedFips);
            });

            countySelect.addEventListener('change', () => {
                const selectedCountyFips = countySelect.value;
                wealthMigrationCountyFips = selectedCountyFips ? `${wealthMigrationStateFips}${selectedCountyFips}` : null;
                wealthMigrationCountyName = selectedCountyFips
                    ? (countySelect.selectedOptions[0]?.textContent?.trim() || '')
                    : '';
                if (selectedCountyFips) {
                    fetchWealthMigrationData(wealthMigrationStateFips, selectedCountyFips);
                } else {
                    showWealthMigrationFallback('Select a county to view wealth migration trends.');
                }
            });

            await loadWealthMigrationCounties(
                wealthMigrationStateFips,
                reportData?.county || reportData?.county_name || '',
                reportData?.county_fips
            );
        }

        async function loadWealthMigrationCounties(stateFips, preferCountyName = '', preferCountyFips = '') {
            const countySelect = document.getElementById('wealthMigrationCountySelect');
            if (!countySelect) return;
            countySelect.disabled = true;
            countySelect.innerHTML = '<option value="">Loading counties...</option>';

            try {
                if (!stateFips) {
                    throw new Error('State FIPS is required to load counties');
                }
                const response = await fetch(`${API_BASE}/migration/counties?stateFips=${encodeURIComponent(stateFips)}`);
                const payload = await response.json();
                if (!response.ok || !payload.success) {
                    throw new Error(payload.error || `Failed to load counties for ${stateFips}`);
                }
                const counties = Array.isArray(payload.data) ? payload.data : [];
                if (counties.length === 0) {
                    throw new Error(`No counties available for ${stateFips}`);
                }

                countySelect.innerHTML = '<option value="">Select County</option>';
                counties.forEach(county => {
                    const option = document.createElement('option');
                    const optionValue = String(
                        county.CountyFips || county.countyFips || county.county_fips || county.id || ''
                    ).replace(/\D/g, '').padStart(3, '0');
                    const optionLabel = county.CountyName || county.countyName || county.county_name || county.name || '';
                    if (!optionValue || !optionLabel) return;
                    option.value = optionValue;
                    option.textContent = optionLabel;
                    countySelect.appendChild(option);
                });

                const preferLabel = normalizeCountyLabel(preferCountyName);
                let normalizedPreferFips = String(preferCountyFips || '').replace(/\D/g, '');
                if (normalizedPreferFips.length === 5) {
                    normalizedPreferFips = normalizedPreferFips.slice(-3);
                }
                if (normalizedPreferFips && normalizedPreferFips.length !== 3) {
                    normalizedPreferFips = '';
                }

                let selectedCountyCode = '';
                if (normalizedPreferFips && Array.from(countySelect.options).some(opt => opt.value === normalizedPreferFips)) {
                    selectedCountyCode = normalizedPreferFips;
                }
                if (!selectedCountyCode && preferLabel) {
                    const match = Array.from(countySelect.options).find(option =>
                        normalizeCountyLabel(option.textContent) === preferLabel
                    );
                    if (match) {
                        selectedCountyCode = match.value;
                    }
                }
                if (!selectedCountyCode && wealthMigrationCountyFips?.startsWith(stateFips)) {
                    selectedCountyCode = wealthMigrationCountyFips.slice(-3);
                }
                if (!selectedCountyCode) {
                    const palmBeach = Array.from(countySelect.options).find(option =>
                        option.textContent === 'Palm Beach County'
                    );
                    selectedCountyCode = palmBeach?.value || countySelect.options[1]?.value || '';
                }

                countySelect.value = selectedCountyCode;
                wealthMigrationCountyFips = selectedCountyCode ? `${stateFips}${selectedCountyCode}` : null;
                wealthMigrationCountyName = countySelect.selectedOptions[0]?.textContent?.trim() || '';
                countySelect.disabled = false;
                if (selectedCountyCode) {
                    await fetchWealthMigrationData(stateFips, selectedCountyCode);
                } else {
                    showWealthMigrationFallback('Select a county to view wealth migration trends.');
                }
            } catch (error) {
                console.error('Wealth migration counties load error:', error);
                countySelect.innerHTML = '<option value="">Counties unavailable</option>';
                wealthMigrationCountyFips = null;
                wealthMigrationCountyName = '';
                showWealthMigrationFallback('County list unavailable for this state.');
            } finally {
                countySelect.disabled = countySelect.options.length <= 1;
            }
        }

        function initializeWealthMigrationSection(reportData) {
            const section = document.getElementById('wealth-migration-section');
            if (!section) return;

            setupWealthMigrationSelectors(reportData).catch(error => {
                console.error('Wealth migration initialization failed:', error);
                showWealthMigrationFallback('Wealth migration controls are unavailable.');
            });

            const toggleButtons = section.querySelectorAll('.wealth-toggle-btn');
            toggleButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (button.classList.contains('active')) return;
                    toggleButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    wealthMigrationDirection = button.dataset.direction === 'outflow' ? 'outflow' : 'inflow';
                    updateWealthMigrationHeader();
                    renderWealthMigrationChart(wealthMigrationDirection);
                    renderWealthMigrationList(wealthMigrationDirection);
                });
            });
        }

        async function fetchWealthMigrationData(stateFips, countyFips, limit = WEALTH_MIGRATION_LIMIT) {
            const loadingEl = document.getElementById('wealthMigrationChartLoading');
            if (loadingEl) {
                loadingEl.style.display = 'flex';
            }
            const normalizedStateFips = String(stateFips || '').replace(/\D/g, '').padStart(2, '0');
            const normalizedCountyFips = String(countyFips || '').replace(/\D/g, '').padStart(3, '0');
            if (!/^\d{2}$/.test(normalizedStateFips) || !/^\d{3}$/.test(normalizedCountyFips)) {
                showWealthMigrationFallback('Select a county to view wealth migration trends.');
                if (loadingEl) loadingEl.style.display = 'none';
                return;
            }
            try {
                const params = new URLSearchParams({
                    stateFips: normalizedStateFips,
                    countyFips: normalizedCountyFips
                });
                const response = await fetch(`${API_BASE}/county-migration?${params.toString()}`);
                const payload = await response.json();
                if (!response.ok || !payload.success) {
                    throw new Error(payload.error || `Status ${response.status}`);
                }

                const normalizeMigrationRows = (rows) => {
                    if (!Array.isArray(rows)) {
                        return { rows: [], latest: null };
                    }
                    const prepared = rows.map(row => ({
                        partner_county: row.partner_county || row.countyName || row.county_name || '',
                        partner_state: row.partner_state || row.stateName || row.state_name || '',
                        returns: Number(row.returns) || 0,
                        individuals: Number(row.individuals) || 0,
                        agi: Number(row.agi) || 0,
                        toYear: Number(row.toYear || row.to_year || row.tax_year || row.year2year || row.latestYear || row.latest_year || null) || null
                    })).filter(row => {
                        const label = `${row.partner_county} ${row.partner_state}`.trim();
                        return row.partner_county &&
                            !WEALTH_MIGRATION_EXCLUDE_PATTERNS.some(pattern => pattern.test(label));
                    });
                    const latest = prepared.reduce((max, row) => row.toYear && row.toYear > max ? row.toYear : max, 0);
                    const seen = new Set();
                    const deduped = [];
                    prepared
                        .filter(row => !latest || row.toYear === latest)
                        .forEach(row => {
                            const key = `${row.partner_county}|${row.partner_state}`;
                            if (seen.has(key)) {
                                return;
                            }
                            seen.add(key);
                            deduped.push(row);
                        });
                    return { rows: deduped.slice(0, limit), latest: latest || null };
                };

                const inflowResult = normalizeMigrationRows(payload.inflow);
                const outflowResult = normalizeMigrationRows(payload.outflow);
                const resolvedCountyName = payload.countyName || wealthMigrationCountyName || '';
                const resolvedStateName = payload.stateName
                    || wealthMigrationStateLookup.get(normalizedStateFips)
                    || wealthMigrationState
                    || DEFAULT_WEALTH_MIGRATION_STATE;
                wealthMigrationCountyFips = `${normalizedStateFips}${normalizedCountyFips}`;
                wealthMigrationCountyName = resolvedCountyName;
                wealthMigrationPayload = {
                    stateName: resolvedStateName,
                    countyName: resolvedCountyName,
                    countyFips: `${normalizedStateFips}${normalizedCountyFips}`,
                    latestYear: inflowResult.latest || outflowResult.latest || payload.latestYear || null,
                    inflow: inflowResult.rows,
                    outflow: outflowResult.rows
                };

                updateWealthMigrationHeader();
                renderWealthMigrationChart(wealthMigrationDirection);
                renderWealthMigrationList(wealthMigrationDirection);
                updateChartContainers();
            } catch (error) {
                console.error('Wealth migration load error:', error);
                showWealthMigrationFallback('Wealth migration data is unavailable right now.');
            } finally {
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
            }
        }

        function updateWealthMigrationHeader() {
            const yearEl = document.getElementById('wealthMigrationYear');
            if (yearEl) {
                yearEl.textContent = wealthMigrationPayload.latestYear
                    ? `Tax Year ${wealthMigrationPayload.latestYear}`
                    : 'Latest available tax year';
            }
            const listTitle = document.getElementById('wealthMigrationListTitle');
            if (listTitle) {
                listTitle.textContent = wealthMigrationDirection === 'outflow'
                    ? 'Top Destinations (Counties)'
                    : 'Top Origins (Counties)';
            }
        }

        function getWealthDataset(direction) {
            const dir = direction === 'outflow' ? 'outflow' : 'inflow';
            const rows = wealthMigrationPayload[dir] || [];
            return rows.slice(0, WEALTH_MIGRATION_LIMIT);
        }

        function renderWealthMigrationChart(direction) {
            const canvas = document.getElementById('wealthMigrationChart');
            const fallbackEl = document.getElementById('wealthMigrationChartFallback');
            if (!canvas) return;

            const dataset = getWealthDataset(direction);
            if (wealthMigrationChartInstance) {
                wealthMigrationChartInstance.destroy();
                wealthMigrationChartInstance = null;
            }

            if (!dataset.length) {
                if (fallbackEl) {
                    fallbackEl.hidden = false;
                    fallbackEl.style.display = 'flex';
                }
                syncWealthMigrationListHeight();
                return;
            }

            if (fallbackEl) {
                fallbackEl.hidden = true;
                fallbackEl.style.display = 'none';
            }

            const ctx = canvas.getContext('2d');
            wealthMigrationChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dataset.map(row => {
                        const parts = [];
                        if (row.partner_county) parts.push(row.partner_county);
                        if (row.partner_state) parts.push(row.partner_state);
                        return parts.length > 0 ? parts.join(', ') : 'Unknown';
                    }),
                    datasets: [{
                        label: 'Tax Returns',
                        data: dataset.map(row => Number(row.returns) || 0),
                        backgroundColor: 'rgba(15, 23, 42, 0.85)',
                        borderRadius: 8,
                        barThickness: 18
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: context => {
                                    const entry = dataset[context.dataIndex];
                                    const lines = [`Returns: ${formatWealthCount(context.raw)}`];
                                    if (entry && Number(entry.returns) > 0) {
                                        const avgIncome = Number(entry.agi || 0) / Number(entry.returns);
                                        if (avgIncome > 0) {
                                            lines.push(`Avg AGI: ${formatWealthCurrency(avgIncome)}`);
                                        }
                                    }
                                    return lines;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(15, 23, 42, 0.08)'
                            },
                            ticks: {
                                callback: value => formatWealthCount(value)
                            }
                        },
                        y: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
            syncWealthMigrationListHeight();
        }

        function renderWealthMigrationList(direction) {
            const list = document.getElementById('wealthMigrationList');
            const placeholder = document.getElementById('wealthMigrationListEmpty');
            if (!list) return;
            list.innerHTML = '';

            const dataset = getWealthDataset(direction);
            if (!dataset.length) {
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
                syncWealthMigrationListHeight();
                return;
            }
            if (placeholder) {
                placeholder.style.display = 'none';
            }

            dataset.forEach((row, index) => {
                const li = document.createElement('li');
                li.className = 'wealth-list-item';
                const avgIncome = Number(row.returns) > 0 ? Number(row.agi || 0) / Number(row.returns) : 0;
                li.innerHTML = `
                    <div class="wealth-list-rank">#${index + 1}</div>
                    <div class="wealth-list-details">
                        <p class="wealth-list-state">${escapeHtml(row.partner_county || 'Unknown')}</p>
                        <p class="wealth-list-substate">${escapeHtml(row.partner_state || '')}</p>
                        <div class="wealth-list-meta">
                            <span>Returns: ${formatWealthCount(row.returns)}</span>
                            <span>Individuals: ${formatWealthCount(row.individuals)}</span>
                            <span>AGI: ${formatWealthCurrency(row.agi)}</span>
                            ${avgIncome ? `<span>Avg AGI: ${formatWealthCurrency(avgIncome)}</span>` : ''}
                        </div>
                    </div>
                `;
                list.appendChild(li);
            });
            syncWealthMigrationListHeight();
        }

        function showWealthMigrationFallback(message) {
            if (wealthMigrationChartInstance) {
                wealthMigrationChartInstance.destroy();
                wealthMigrationChartInstance = null;
            }
            const fallbackEl = document.getElementById('wealthMigrationChartFallback');
            if (fallbackEl) {
                fallbackEl.hidden = false;
                fallbackEl.style.display = 'flex';
                fallbackEl.textContent = message || 'Wealth migration data is unavailable right now.';
            }
            const placeholder = document.getElementById('wealthMigrationListEmpty');
            if (placeholder) {
                placeholder.style.display = 'block';
                placeholder.textContent = message || 'Wealth migration data is unavailable right now.';
            }
            const list = document.getElementById('wealthMigrationList');
            if (list) {
                list.innerHTML = '';
            }
        }

        function formatWealthCurrency(value) {
            const num = Number(value);
            if (!Number.isFinite(num) || num <= 0) {
                return 'N/A';
            }
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                maximumFractionDigits: 0
            }).format(num);
        }

        function formatWealthCount(value) {
            const num = Number(value);
            if (!Number.isFinite(num)) {
                return 'N/A';
            }
            return num.toLocaleString();
        }
        
        // Function to display stats error
        function displayStatsError(message) {
            const statsSection = document.querySelector('#homeStatsContent > div:last-child');
            if (statsSection) {
                statsSection.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; min-height: 150px;">
                        <div style="text-align: center;">
                            <div style="color: #e74c3c; font-size: 32px; margin-bottom: 15px;">📊</div>
                            <h3 style="margin: 0; color: #2c3e50; font-size: 18px; font-weight: 300; letter-spacing: 1px; text-transform: uppercase; margin-bottom: 8px;">Stats</h3>
                            <div style="width: 60px; height: 2px; background: linear-gradient(90deg, #3498db, #27ae60); margin: 8px auto 15px;"></div>
                            <p style="margin: 0; color: #e74c3c; font-size: 13px;">${message}</p>
                        </div>
                    </div>
                `;
            }
        }
        // FRED series configuration
        const FRED_SERIES = {
            'GDP': 'GDP',
            'CPIAUCSL': 'CPI',
            'PPIACO': 'PPI',
            'FEDFUNDS': 'Fed Funds Rate',
            'MORTGAGE30US': '30-Year Mortgage',
            'MORTGAGE15US': '15-Year Mortgage',
            'RHVRUSQ156N': 'Vacancy Rate',
            'LREM64TTUSM156S': 'Employment',
            'POPTHM': 'Population',
            'M2REAL': 'Money Stock',
            'FPCPITOTLZGUSA': 'Inflation',
            'GFDEBTN': 'Government Debt',
            'DGS10': '10-Year Treasury',
            'DGS2': '2-Year Treasury',
            'ACTLISCOUUS': 'Active Listings',
            'MSPUS': 'Median Sale Price',
            'NEWLISCOUUS': 'New Listings',
            'MEDDAYONMARUS': 'Median Days on Market',
            'USSTHPI': 'Housing Price Index',
            'UNRATE': 'Unemployment Rate',
            'DJIA': 'Dow Jones Industrial Average'
        };

        // National chart explanations (1–2 sentences each)
        const FRED_SERIES_DESCRIPTIONS = {
            'GDP': 'Total output of the U.S. economy. Rising GDP signals economic expansion; declines can indicate slowdowns or recessions.',
            'CPIAUCSL': 'Consumer price index measuring average price changes for urban consumers. Higher CPI indicates stronger inflation.',
            'PPIACO': 'Producer Price Index for all commodities. Tracks prices received by domestic producers and can lead consumer inflation.',
            'FEDFUNDS': 'Effective federal funds rate targeted by the Federal Reserve. Influences borrowing costs across the economy.',
            'MORTGAGE30US': 'Average interest rate on 30‑year fixed mortgages. Affects home affordability and buyer demand.',
            'MORTGAGE15US': 'Average interest rate on 15‑year fixed mortgages. Lower terms often have lower rates than 30‑year loans.',
            'RHVRUSQ156N': 'National rental vacancy rate. Higher values suggest looser rental markets; lower values indicate tighter supply.',
            'LREM64TTUSM156S': 'Total U.S. employment level. Growth points to a strengthening labor market and economy.',
            'POPTHM': 'Estimated U.S. population. Long‑term growth supports housing demand and economic activity.',
            'M2REAL': 'Inflation‑adjusted broad money supply (Real M2). Changes can reflect liquidity conditions in the economy.',
            'FPCPITOTLZGUSA': 'Annual consumer price inflation (World Bank). Indicates the pace of general price increases.',
            'GFDEBTN': 'Total U.S. federal public debt outstanding. Useful for context on fiscal conditions and interest costs.',
            'DGS10': '10‑year U.S. Treasury yield. Key benchmark for long‑term borrowing costs and mortgage rates.',
            'DGS2': '2‑year U.S. Treasury yield. Closely tracks expectations for Fed policy over the near term.',
            'ACTLISCOUUS': 'Number of homes actively listed for sale nationwide. Lower inventory often supports price growth.',
            'MSPUS': 'Median sale price of U.S. homes. Reflects typical transaction prices and market trends.',
            'NEWLISCOUUS': 'New residential listings entering the market. A gauge of seller activity and fresh supply.',
            'MEDDAYONMARUS': 'Median number of days homes spend on the market. Fewer days indicate stronger buyer demand.',
            'USSTHPI': 'FHFA national home price index. Measures changes in single‑family home values over time.',
            'UNRATE': 'U.S. unemployment rate. Lower rates indicate a tighter labor market and stronger economy.',
            'DJIA': 'Dow Jones Industrial Average stock index. A snapshot of large U.S. companies and market sentiment.'
        };

        function getSeriesDescription(seriesId) {
            return FRED_SERIES_DESCRIPTIONS[seriesId] || '';
        }

        function updateNationalChartUI() {
            try {
                const leftId = document.getElementById('leftChartSelect')?.value;
                const rightId = document.getElementById('rightChartSelect')?.value;
                const leftTitleEl = document.getElementById('leftChartTitleText');
                const rightTitleEl = document.getElementById('rightChartTitleText');
                const leftInfoIcon = document.getElementById('leftInfoIcon');
                const rightInfoIcon = document.getElementById('rightInfoIcon');
                const leftDescEl = document.getElementById('leftChartDescription');
                const rightDescEl = document.getElementById('rightChartDescription');

                if (leftId && leftTitleEl) leftTitleEl.textContent = (FRED_SERIES[leftId] || leftId);
                if (rightId && rightTitleEl) rightTitleEl.textContent = (FRED_SERIES[rightId] || rightId);
                const leftSub = document.getElementById('leftChartSubtitle');
                const rightSub = document.getElementById('rightChartSubtitle');
                if (leftSub) leftSub.textContent = 'Source: Federal Reserve';
                if (rightSub) rightSub.textContent = 'Source: Federal Reserve';

                const leftDesc = leftId ? getSeriesDescription(leftId) : '';
                const rightDesc = rightId ? getSeriesDescription(rightId) : '';
                // Do not set native title to avoid hover popups
                // Close any open popovers when changing series
                if (leftInfoIcon && leftInfoIcon._popover) { leftInfoIcon._popover.remove(); leftInfoIcon._popover = null; }
                if (rightInfoIcon && rightInfoIcon._popover) { rightInfoIcon._popover.remove(); rightInfoIcon._popover = null; }
                if (leftDescEl) leftDescEl.textContent = leftDesc;
                if (rightDescEl) rightDescEl.textContent = rightDesc;
            } catch {}
        }

        function setupNationalInfoToggles() {
            try {
                const leftIcon = document.getElementById('leftInfoIcon');
                const rightIcon = document.getElementById('rightInfoIcon');
                const leftDescEl = document.getElementById('leftChartDescription');
                const rightDescEl = document.getElementById('rightChartDescription');

                const createPopover = (anchorEl, content, side = 'bottom') => {
                    // Remove an existing popover first
                    const existing = anchorEl._popover;
                    if (existing) { existing.remove(); anchorEl._popover = null; }
                    // Create popover container
                    const pop = document.createElement('div');
                    pop.className = 'chart-popover';
                    pop.setAttribute('data-side', side);
                    pop.textContent = content;
                    const arrow = document.createElement('div');
                    arrow.className = 'chart-popover-arrow';
                    pop.appendChild(arrow);
                    document.body.appendChild(pop);
                    // Positioning
                    const rect = anchorEl.getBoundingClientRect();
                    const popRect = pop.getBoundingClientRect();
                    let top = rect.bottom + window.scrollY + 8;
                    let left = rect.left + window.scrollX + Math.round(rect.width / 2 - popRect.width / 2);
                    // Clamp within viewport with 8px margin
                    const margin = 8;
                    const maxLeft = window.scrollX + document.documentElement.clientWidth - popRect.width - margin;
                    const minLeft = window.scrollX + margin;
                    left = Math.max(minLeft, Math.min(maxLeft, left));
                    const maxTop = window.scrollY + document.documentElement.clientHeight - popRect.height - margin;
                    const minTop = window.scrollY + margin;
                    top = Math.max(minTop, Math.min(maxTop, top));
                    pop.style.top = `${top}px`;
                    pop.style.left = `${left}px`;
                    // Position arrow relative to anchor center but within pop width
                    const anchorCenter = rect.left + window.scrollX + rect.width / 2;
                    let arrowLeft = Math.round(anchorCenter - left - 5);
                    arrowLeft = Math.max(6, Math.min(popRect.width - 16, arrowLeft));
                    arrow.style.top = `-5px`;
                    arrow.style.left = `${arrowLeft}px`;
                    anchorEl._popover = pop;
                    // Dismiss on outside click or Escape
                    const onDocClick = (e) => {
                        if (!pop.contains(e.target) && e.target !== anchorEl) {
                            destroyPopover(anchorEl);
                            document.removeEventListener('click', onDocClick);
                        }
                    };
                    setTimeout(() => document.addEventListener('click', onDocClick), 0);
                    const onKey = (e) => { if (e.key === 'Escape') destroyPopover(anchorEl); };
                    document.addEventListener('keydown', onKey, { once: true });
                };

                const destroyPopover = (anchorEl) => {
                    if (anchorEl && anchorEl._popover) {
                        anchorEl._popover.remove();
                        anchorEl._popover = null;
                    }
                };

                const makeInteractive = (iconEl, descEl) => {
                    if (!iconEl || !descEl) return;
                    iconEl.setAttribute('tabindex', '0');
                    const show = () => createPopover(iconEl, descEl.textContent || iconEl.title || '');
                    const hide = () => destroyPopover(iconEl);
                    iconEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (iconEl._popover) hide(); else show();
                    });
                    iconEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            if (iconEl._popover) hide(); else show();
                        }
                    });
                };

                makeInteractive(leftIcon, leftDescEl);
                makeInteractive(rightIcon, rightDescEl);
            } catch {}
        }

        // Function to fetch and display FRED charts
        async function loadFredCharts(reportId) {
            let leftSeriesId = 'USSTHPI';  // Default
            let rightSeriesId = 'DJIA';    // Default
            
            try {
                // Load saved FRED charts from database
                const response = await fetch(`${API_BASE}/reports/${reportId}/fred-charts`);
                const result = await response.json();
                
                if (response.ok && result.success && result.data.length > 0) {
                    // Find left and right charts by chart_id (smaller = left, larger = right)
                    const sortedCharts = result.data.sort((a, b) => a.chart_id - b.chart_id);
                    const leftChart = sortedCharts[0];
                    const rightChart = sortedCharts[1];
                    
                    if (leftChart) leftSeriesId = leftChart.series_id;
                    if (rightChart) rightSeriesId = rightChart.series_id;
                }
            } catch (error) {
                console.error('Error loading FRED charts from database:', error);
                // Continue with defaults
            }
            
            // Set dropdown values and titles/descriptions
            document.getElementById('leftChartSelect').value = leftSeriesId;
            document.getElementById('rightChartSelect').value = rightSeriesId;
            updateNationalChartUI();
            
            // Setup dropdown event listeners with save functionality
            document.getElementById('leftChartSelect').addEventListener('change', async function() {
                const seriesId = this.value;
                const title = FRED_SERIES[seriesId] || seriesId;
                updateNationalChartUI();
                loadChartData('leftChart', seriesId, '#2E8B57');
                
                // Save to database
                await saveFredCharts(reportId);
            });
            
            document.getElementById('rightChartSelect').addEventListener('change', async function() {
                const seriesId = this.value;
                const title = FRED_SERIES[seriesId] || seriesId;
                updateNationalChartUI();
                loadChartData('rightChart', seriesId, '#1E90FF');
                
                // Save to database
                await saveFredCharts(reportId);
            });

            // Load initial charts
            loadChartData('leftChart', leftSeriesId, '#2E8B57');
            loadChartData('rightChart', rightSeriesId, '#1E90FF');
        }
        // Function to save FRED charts to database
        async function saveFredCharts(reportId) {
            try {
                const leftSeriesId = document.getElementById('leftChartSelect').value;
                const rightSeriesId = document.getElementById('rightChartSelect').value;
                
                const response = await fetch(`${API_BASE}/reports/${reportId}/fred-charts`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        leftSeriesId: leftSeriesId,
                        rightSeriesId: rightSeriesId
                    })
                });
                
                const result = await response.json();
                if (!response.ok || !result.success) {
                    console.error('Error saving FRED charts:', result.error);
                }
            } catch (error) {
                console.error('Error saving FRED charts:', error);
            }
        }

        // Function to load chart data
        function loadChartData(containerId, seriesId, color) {
            const currentDate = new Date();
            const fiveYearsAgo = new Date(currentDate.getFullYear() - 5, currentDate.getMonth(), currentDate.getDate());
            
            const startDate = fiveYearsAgo.toISOString().split('T')[0];
            const endDate = currentDate.toISOString().split('T')[0];
            
            const title = FRED_SERIES[seriesId] || seriesId;
            loadFredChart(seriesId, containerId, startDate, endDate, title, color);

            // Update inline descriptions and tooltips after data load trigger
            updateNationalChartUI();
        }
        // Function to load individual FRED chart
        async function loadFredChart(seriesId, containerId, startDate, endDate, title, color) {
            try {
                const response = await fetch(`${API_BASE}/fred-data?seriesId=${seriesId}&startDate=${startDate}&endDate=${endDate}`);
                const data = await response.json();
                
                if (data.observations && data.observations.length > 0) {
                    renderChart(containerId, data.observations, title, color);
                } else {
                    // Show no data message
                    const canvas = document.getElementById(containerId);
                    const loadingDiv = document.getElementById(containerId + '-loading');
                    if (loadingDiv) {
                        loadingDiv.style.display = 'none';
                    }
                    if (canvas) {
                        const parent = canvas.parentElement;
                        parent.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; text-align: center; color: #666;">
                                <p>No data available for ${title}</p>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error(`Error loading ${seriesId} data:`, error);
                const canvas = document.getElementById(containerId);
                const loadingDiv = document.getElementById(containerId + '-loading');
                if (loadingDiv) {
                    loadingDiv.style.display = 'none';
                }
                if (canvas) {
                    const parent = canvas.parentElement;
                    parent.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; text-align: center; color: #e74c3c;">
                            <p>Error loading ${title} data</p>
                        </div>
                    `;
                }
            }
        }
        // Function to render a simple line chart using Chart.js
        function renderChart(containerId, observations, title, color) {
            const canvas = document.getElementById(containerId);
            const loadingDiv = document.getElementById(containerId + '-loading');
            
            if (!canvas) {
                console.error(`Canvas element ${containerId} not found`);
                return;
            }
            
            // Hide loading spinner
            if (loadingDiv) {
                loadingDiv.style.display = 'none';
            }
            
            const validData = observations.filter(obs => obs.value !== '.' && !isNaN(parseFloat(obs.value)));
            
            if (validData.length === 0) {
                // Show error message
                const parent = canvas.parentElement;
                parent.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; text-align: center; color: #666;">
                        <p>No valid data available for ${title}</p>
                    </div>
                `;
                return;
            }

            // Get chart instance based on container ID
            let chartInstance;
            if (containerId === 'leftChart') {
                chartInstance = leftChartInstance;
            } else if (containerId === 'rightChart') {
                chartInstance = rightChartInstance;
            }

            // Destroy existing chart if it exists
            if (chartInstance) {
                chartInstance.destroy();
            }

            // Prepare data for Chart.js
            const chartData = validData.map(obs => ({
                x: obs.date,
                y: parseFloat(obs.value)
            }));

            const ctx = canvas.getContext('2d');
            
            // Create Chart.js configuration
            const config = {
                type: 'line',
                data: {
                    datasets: [{
                        label: title,
                        data: chartData,
                        backgroundColor: color + '20', // 20% opacity for fill
                        borderColor: color,
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: (window.innerWidth <= 768 ? 0 : 3),
                        pointHoverRadius: (window.innerWidth <= 768 ? 0 : 6),
                        pointHoverBackgroundColor: color,
                        pointHoverBorderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(tooltipItems) {
                                    const date = new Date(tooltipItems[0].parsed.x);
                                    return date.toLocaleDateString();
                                },
                                label: function(context) {
                                    return `${title}: ${context.parsed.y.toLocaleString()}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM yyyy'
                                }
                            },
                            grid: {
                                display: true,
                                color: '#f0f0f0'
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    size: 11
                                }
                            }
                        },
                        y: {
                            grid: {
                                display: true,
                                color: '#f0f0f0'
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false
                    },
                    elements: {
                        line: {
                            tension: 0.4
                        }
                    }
                }
            };

            // Create the chart and store the instance
            const newChart = new Chart(ctx, config);
            
            if (containerId === 'leftChart') {
                leftChartInstance = newChart;
            } else if (containerId === 'rightChart') {
                rightChartInstance = newChart;
            }
        }

        // FRED Comparison Functionality for Area Charts
        let seriesOptionsCache = null;
        let selectionCount = 1;
        const maxSelections = 5;
        
        // Chart.js instances for FRED charts
        let leftChartInstance = null;
        let rightChartInstance = null;
        let comparisonChartInstance = null;
        
        // Chart.js instances for popup charts
        let salesCountChartInstance = null;
        let avgPriceChartInstance = null;
        
        // Available states for county selection (alphabetically sorted)
        const availableStates = [
            'Alabama', 'Arizona', 'California', 'Colorado', 'Connecticut', 'Florida',
            'Georgia', 'Illinois', 'Indiana', 'Kentucky', 'Louisiana', 'Maryland',
            'Massachusetts', 'Michigan', 'Minnesota', 'Missouri', 'New Jersey', 'New York',
            'North Carolina', 'Ohio', 'Oklahoma', 'Oregon', 'Pennsylvania', 'South Carolina',
            'Tennessee', 'Texas', 'Utah', 'Virginia', 'Washington', 'Wisconsin'
        ];
        
        // Initialize FRED comparison functionality
        async function initializeFredComparison() {
            try {
                // Load series options
                await loadSeriesOptions();
                
                // Load saved comparison data for this report
                await loadSavedComparison();
                
                // Setup event listeners
                setupEventListeners();
                
            } catch (error) {
                console.error('Error initializing FRED comparison:', error);
                document.getElementById('chartsContent').innerHTML = `
                    <div class="info-item">
                        <div class="info-label">Area Charts</div>
                        <div class="info-value">Unable to load comparison tools. Please try refreshing the page.</div>
                    </div>
                `;
            }
        }
        
        // Load available FRED series from database
        async function loadSeriesOptions() {
            const seriesSelect = document.getElementById('series-select');
            if (!seriesSelect) {
                console.error('series-select element not found');
                throw new Error('series-select element not found in DOM');
            }
            seriesSelect.innerHTML = '';
            seriesOptionsCache = {};

            REALTOR_METRICS.forEach(metric => {
                seriesOptionsCache[metric.key] = metric;
                const option = document.createElement('option');
                option.value = metric.key;
                option.textContent = metric.label;
                seriesSelect.appendChild(option);
            });

            seriesSelect.value = DEFAULT_COUNTY_METRIC;
        }
        
        // Load saved comparison data for this report
        async function loadSavedComparison() {
            try {
                console.log('Loading saved comparison for report:', urlSlug);
                const response = await fetch(`${API_BASE}/reports/${urlSlug}/area-comparison`);
                const result = await response.json();
                
                if (response.ok && result.success && result.data) {
                    const savedData = result.data;
                    console.log('Found saved comparison:', savedData);
                    
                    // Set the series selection
                    if (savedData.series_id) {
                        document.getElementById('series-select').value = savedData.series_id;
                    }
                    
                    // Load the county locations and populate dropdowns
                    if (savedData.locations && savedData.locations.length > 0) {
                        await loadSavedLocations(savedData.locations);
                        // Auto-generate the chart with the loaded data
                        await generateComparison();
                    } else {
                        // No saved data, initialize with default Palm Beach County
                        resetToDefault();
                    }
                } else {
                    console.log('No saved comparison found, using defaults');
                    // No saved data, initialize with default Palm Beach County
                    resetToDefault();
                }
            } catch (error) {
                console.error('Error loading saved comparison:', error);
                // Fallback to default
                resetToDefault();
            }
        }
        
        // Load saved locations and populate the dropdowns
        async function loadSavedLocations(countyIds) {
            try {
                if (!window.__savedCountyNames) window.__savedCountyNames = {};
                if (!window.__savedCountyMetadata) window.__savedCountyMetadata = {};
                // Set the selection count based on saved locations
                selectionCount = countyIds.length;
                
                // Update the location selections UI
                await updateLocationSelections();
                
                // For each saved county ID, we need to find the state and set the dropdowns
                for (let i = 0; i < countyIds.length; i++) {
                    const countyId = countyIds[i];
                    const selectionIndex = i + 1;
                    
                    const countyInfo = await loadCountyById(countyId, selectionIndex);
                    if (countyInfo && countyInfo.name) {
                        window.__savedCountyNames[countyId] = countyInfo.name;
                        window.__savedCountyMetadata[countyId] = countyInfo;
                    }
                }
                
                updateButtons();
                
            } catch (error) {
                console.error('Error loading saved locations:', error);
                await resetToDefault();
            }
        }
        
        // Load county info by ID and set the appropriate dropdowns
        async function loadCountyById(countyId, selectionIndex) {
            try {
                // We need to find which state this county belongs to
                // We'll try each state until we find the county
                for (const state of availableStates) {
                    const response = await fetch(`${API_BASE}/counties?state=${encodeURIComponent(state)}`);
                    const result = await response.json();
                    
                    if (response.ok && result.success) {
                        const county = result.data.find(c => c.id === countyId);
                        if (county) {
                            const stateSelect = document.getElementById(`state-select-${selectionIndex}`);
                            const countySelect = document.getElementById(`county-select-${selectionIndex}`);

                            if (stateSelect && countySelect) {
                                stateSelect.value = state;
                                countySelect.innerHTML = '<option value="">Select County</option>';
                                const sortedCounties = result.data.sort((a, b) => a.name.localeCompare(b.name));
                                sortedCounties.forEach(countyOption => {
                                    const option = document.createElement('option');
                                    option.value = countyOption.id;
                                    option.textContent = countyOption.name;
                                    if (countyOption.id === countyId) {
                                        option.selected = true;
                                    }
                                    countySelect.appendChild(option);
                                });
                            }

                            return { state, name: county.name, id: county.id };
                        }
                    }
                }
                
                console.warn(`County ID ${countyId} not found in any state`);
            } catch (error) {
                console.error(`Error loading county by ID ${countyId}:`, error);
            }
        }
        
        // Setup event listeners for the comparison controls
        function setupEventListeners() {
            document.getElementById('add-location-btn').addEventListener('click', async () => {
                await addLocationSelection();
            });
            document.getElementById('remove-location-btn').addEventListener('click', async () => {
                await removeLocationSelection();
            });
            document.getElementById('compare-btn').addEventListener('click', async () => {
                const seriesSelect = document.getElementById('series-select');
                if (seriesSelect && (!seriesSelect.value || !realtorSeriesKeys.has(seriesSelect.value))) {
                    seriesSelect.value = DEFAULT_COUNTY_METRIC;
                }
                await generateComparison();
                showChartView(true);
            });
            document.getElementById('reset-comparison-btn').addEventListener('click', resetToDefault);
            document.getElementById('back-to-controls-btn').addEventListener('click', showControlsView);
            document.getElementById('chart-series-select').addEventListener('change', refreshChartWithNewIndicator);
        }
        
        // Show the controls view and hide the chart view
        function showControlsView() {
            document.getElementById('controls-section').style.display = 'block';
            document.getElementById('chart-section').style.display = 'none';
        }
        // Show the chart view and hide the controls view  
        function showChartView(autoGenerated) {
            document.getElementById('controls-section').style.display = 'none';
            document.getElementById('chart-section').style.display = 'block';
            populateChartSeriesSelector();
            if (!autoGenerated) {
                const seriesSelect = document.getElementById('series-select');
                const chartSeriesSelect = document.getElementById('chart-series-select');
                if (seriesSelect && (!seriesSelect.value || !realtorSeriesKeys.has(seriesSelect.value))) {
                    seriesSelect.value = DEFAULT_COUNTY_METRIC;
                    if (chartSeriesSelect) {
                        chartSeriesSelect.value = DEFAULT_COUNTY_METRIC;
                    }
                }
            }
        }
        
        // Add a new location selection dropdown
        async function addLocationSelection() {
            if (selectionCount >= maxSelections) return;
            
            selectionCount++;
            await updateLocationSelections();
            updateButtons();
        }
        
        // Remove the last location selection
        async function removeLocationSelection() {
            if (selectionCount <= 1) return;
            
            selectionCount--;
            await updateLocationSelections();
            updateButtons();
        }
        // Update the location selection interface
        async function updateLocationSelections() {
            const container = document.getElementById('location-selections');
            
            // Store current selections before updating
            const currentSelections = {};
            for (let i = 1; i <= Math.max(selectionCount, container.children.length); i++) {
                const stateSelect = document.getElementById(`state-select-${i}`);
                const countySelect = document.getElementById(`county-select-${i}`);
                if (stateSelect && countySelect) {
                    currentSelections[i] = {
                        state: stateSelect.value,
                        county: countySelect.value
                    };
                }
            }
            
            // Only rebuild if we need more elements or fewer elements
            const currentCount = container.children.length;
            
            if (selectionCount > currentCount) {
                // Add new location selections
                for (let i = currentCount + 1; i <= selectionCount; i++) {
                    const locationDiv = document.createElement('div');
                    locationDiv.className = 'location-selection';
                    locationDiv.id = `location-${i}`;
                    locationDiv.innerHTML = `
                        <div>
                            <label>State Selection</label>
                            <select id="state-select-${i}">
                                <option value="">Choose State</option>
                                ${availableStates.map(state => 
                                    `<option value="${state}"${state === 'Florida' && i === 1 ? ' selected' : ''}>${state}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div>
                            <label>County Selection</label>
                            <select id="county-select-${i}">
                                <option value="">Choose County</option>
                            </select>
                        </div>
                    `;
                    container.appendChild(locationDiv);
                    const stateEl = document.getElementById(`state-select-${i}`);
                    if (stateEl) {
                        stateEl.addEventListener('change', () => updateCounties(i));
                    }
                }
            } else if (selectionCount < currentCount) {
                // Remove excess location selections
                for (let i = currentCount; i > selectionCount; i--) {
                    const locationDiv = document.getElementById(`location-${i}`);
                    if (locationDiv) {
                        locationDiv.remove();
                    }
                }
            }
            
            // Restore previous selections
            for (let i = 1; i <= selectionCount; i++) {
                const stateSelect = document.getElementById(`state-select-${i}`);
                const countySelect = document.getElementById(`county-select-${i}`);
                const savedMeta = Object.values(window.__savedCountyMetadata || {}).find(meta => meta.id === currentSelections[i]?.county);
                
                if (currentSelections[i] && currentSelections[i].state) {
                    // Restore state selection
                    stateSelect.value = currentSelections[i].state;
                    
                    // Load counties for this state and then restore county selection
                    await updateCounties(i);
                    
                    // Restore county selection
                    if (currentSelections[i].county) {
                        countySelect.value = currentSelections[i].county;
                    }
                } else if (savedMeta) {
                    stateSelect.value = savedMeta.state;
                    await updateCounties(i);
                    countySelect.value = savedMeta.id;
                } else if (i === 1 && !currentSelections[i]) {
                    // Default first selection to Florida if no previous selection
                    stateSelect.value = 'Florida';
                    await updateCounties(i);
                    countySelect.value = '12099';
                }

                if (window.__savedZipCodes && window.__savedZipCodes[i - 1]) {
                    const zipInput = document.getElementById(`zip-input-${i}`);
                    if (zipInput) {
                        zipInput.value = window.__savedZipCodes[i - 1];
                    }
                }
            }
        }
        
        // Update counties dropdown when state changes
        async function updateCounties(selectionIndex) {
            const stateSelect = document.getElementById(`state-select-${selectionIndex}`);
            const countySelect = document.getElementById(`county-select-${selectionIndex}`);
            
            if (!stateSelect.value) {
                countySelect.innerHTML = '<option value="">Select County</option>';
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/counties?state=${encodeURIComponent(stateSelect.value)}`);
                const result = await response.json();
                
                if (!response.ok || !result.success) {
                    throw new Error('Failed to fetch counties');
                }
                
                countySelect.innerHTML = '<option value="">Select County</option>';
                
                // Sort counties alphabetically by name
                const sortedCounties = result.data.sort((a, b) => a.name.localeCompare(b.name));
                
                sortedCounties.forEach(county => {
                    const option = document.createElement('option');
                    option.value = county.id;
                    option.textContent = county.name;
                    
                    // Default Palm Beach County for Florida
                    if (selectionIndex === 1 && stateSelect.value === 'Florida' && county.name === 'Palm Beach County' && !countySelect.value) {
                        option.selected = true;
                    }
                    
                    countySelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error fetching counties:', error);
                countySelect.innerHTML = '<option value="">Error loading counties</option>';
            }
        }
        
        // Delegate change events for dynamically created state selects (CSP-safe)
        (function attachStateChangeDelegation() {
            const container = document.getElementById('location-selections');
            if (container && !container._delegated) {
                container.addEventListener('change', (e) => {
                    const target = e.target;
                    if (target && target.id && target.id.indexOf('state-select-') === 0) {
                        const parts = String(target.id).split('-');
                        const idxStr = parts[parts.length - 1];
                        const idx = parseInt(idxStr, 10);
                        if (Number.isFinite(idx)) {
                            updateCounties(idx);
                        }
                    }
                });
                container._delegated = true;
            }
        })();
        
        // Update button visibility
        function updateButtons() {
            const addBtn = document.getElementById('add-location-btn');
            const removeBtn = document.getElementById('remove-location-btn');
            
            addBtn.style.display = selectionCount >= maxSelections ? 'none' : 'inline-block';
            removeBtn.style.display = selectionCount <= 1 ? 'none' : 'inline-block';
        }
        
        // Reset to default (Palm Beach County only)
        async function resetToDefault() {
            selectionCount = 1;
            await updateLocationSelections();
            updateButtons();
            
            // Clear any existing chart, header, and notices
            if (comparisonChartInstance) {
                comparisonChartInstance.destroy();
                comparisonChartInstance = null;
            }
            document.getElementById('chart-loading').style.display = 'none';
            document.getElementById('chart-error').style.display = 'none';
            document.getElementById('comparison-chart-header').style.display = 'none';
            document.getElementById('data-availability-notice').style.display = 'none';
            
            // Reset series selection to default
            const seriesSelect = document.getElementById('series-select');
            const defaultSeries = 'ACTIVE_COUNTY_INVENTORY';
            if (seriesOptionsCache && seriesOptionsCache[defaultSeries]) {
                seriesSelect.value = defaultSeries;
            } else if (seriesSelect.options.length > 1) {
                seriesSelect.selectedIndex = 1; // First non-empty option
            }
            
            // Clear saved comparison data
            await clearSavedComparison();
            
            // Switch back to controls view
            showControlsView();
        }
        
        // Clear saved comparison data from database
        async function clearSavedComparison() {
            try {
                // Save empty data to effectively clear the comparison
                const response = await fetch(`${API_BASE}/reports/${urlSlug}/area-comparison`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        seriesId: 'ACTIVE_COUNTY_INVENTORY',
                        countyIds: ['12099'] // Default Palm Beach County
                    })
                });
                
                if (!response.ok) {
                    console.warn('Failed to clear saved comparison data');
                }
            } catch (error) {
                console.error('Error clearing saved comparison data:', error);
            }
        }
        
        // Generate the comparison chart
        async function generateComparison() {
            const seriesSelect = document.getElementById('series-select');
            const selectedSeries = seriesSelect.value;
            
            if (!selectedSeries || !seriesOptionsCache || !realtorSeriesKeys.has(selectedSeries)) {
                document.getElementById('chart-loading').style.display = 'none';
                document.getElementById('chart-error').style.display = 'flex';
                document.getElementById('comparison-chart-header').style.display = 'none';
                return;
            }
            
            // Collect all selections  
            const selections = [];
            let hasValidSelections = false;
            
            for (let i = 1; i <= selectionCount; i++) {
                const stateSelect = document.getElementById(`state-select-${i}`);
                const countySelect = document.getElementById(`county-select-${i}`);
                
                if (stateSelect && countySelect && stateSelect.value && countySelect.value) {
                    const countyId = countySelect.value.trim();
                    selections.push({
                        state: stateSelect.value,
                        county: countyId,
                        countyName: (window.__savedCountyNames && window.__savedCountyNames[countyId]) || countySelect.options[countySelect.selectedIndex]?.text || countyId
                    });
                    hasValidSelections = true;
                }
            }
            
            if (!hasValidSelections) {
                alert('Please select at least one location to compare');
                return;
            }
            
            // Save the comparison data before generating chart
            await saveComparisonData(selectedSeries, selections);
            
            // Switch to chart view and show loading state
            showChartView();
            document.getElementById('chart-loading').style.display = 'flex';
            document.getElementById('chart-error').style.display = 'none';
            if (comparisonChartInstance) {
                comparisonChartInstance.destroy();
                comparisonChartInstance = null;
            }
            
            try {
                const seriesOption = seriesOptionsCache[selectedSeries];
                if (!seriesOption || !realtorSeriesKeys.has(selectedSeries)) {
                    alert('Selected metric is not available. Please choose another option.');
                    return;
                }
                const chartData = {};
                const countyNames = {};
                const unavailableLocations = [];

            const countyData = await fetchCountySeriesData(selections.map(sel => sel.county), selectedSeries);
                console.debug('Transforming countyData for chart', { selectedSeries, countyDataSample: countyData.slice(0, 5) });
            countyData.forEach(({ county, name, points }) => {
                chartData[county] = points;
                countyNames[county] = name;
            });
                selections.forEach(sel => {
                    if (!chartData[sel.county]) {
                        unavailableLocations.push({ name: sel.countyName, seriesId: selectedSeries });
                    }
                });

                document.getElementById('chart-loading').style.display = 'none';

                if (Object.keys(chartData).length === 0) {
                document.getElementById('chart-error').style.display = 'flex';
                document.getElementById('comparison-chart-header').style.display = 'none';
                    return;
                }

                document.getElementById('comparison-chart-header').style.display = 'block';
                console.debug('Rendering chart with data', { seriesOption, chartData });
                createSimpleComparisonChart(chartData, countyNames, seriesOption.label, seriesOption);

            displayDataAvailabilityNotice(unavailableLocations, seriesOption.label);

            } catch (error) {
                console.error('Error generating comparison:', error);
                document.getElementById('chart-loading').style.display = 'none';
                document.getElementById('chart-error').style.display = 'flex';
            }
        }
        // Save comparison data to database
        async function saveComparisonData(seriesId, selections) {
            try {
                console.log('Saving comparison data:', { seriesId, selections });
                
                // Extract county IDs from selections
                const countyIds = selections.map(selection => selection.county);

                const response = await fetch(`${API_BASE}/reports/${urlSlug}/area-comparison`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        seriesId: seriesId,
                        countyIds: countyIds
                    })
                });
                
                const result = await response.json();
                if (!response.ok || !result.success) {
                    console.error('Error saving comparison data:', result.error);
                } else {
                    console.log('Comparison data saved successfully');
                }
            } catch (error) {
                console.error('Error saving comparison data:', error);
                // Don't block the chart generation if save fails
            }
        }
        // Fetch FRED data for a specific series
        async function fetchFredData(seriesId) {
            const endDate = new Date().toISOString().split('T')[0];
            const startDate = new Date(new Date().setFullYear(new Date().getFullYear() - 5))
                .toISOString().split('T')[0];
            
            const response = await fetch(`${API_BASE}/fred-data?seriesId=${seriesId}&startDate=${startDate}&endDate=${endDate}`);
            const data = await response.json();
            
            if (!response.ok) {
                throw new Error(data.error || 'Failed to fetch FRED data');
            }
            
            return data.observations || [];
        }
        // Create a simple comparison chart using Chart.js
        function createSimpleComparisonChart(chartData, countyNames, title, seriesOption) {
            const canvas = document.getElementById('comparison-chart');
            
            if (!canvas) {
                console.error('Comparison chart canvas not found');
                return;
            }
            
            // Function to get color for a county
            function getCountyColor(countyId) {
                const countyName = countyNames[countyId] || '';
                if (countyId === '12099' || countyName.includes('Palm Beach')) {
                    return '#003366';
                }
                const otherColors = ['#e74c3c', '#f39c12', '#27ae60', '#9b59b6', '#3498db', '#e67e22', '#1abc9c', '#34495e', '#f1c40f', '#8e44ad'];
                const nonPalmBeachIds = Object.keys(countyNames).filter(id => id !== '12099' && !countyNames[id].includes('Palm Beach'));
                const colorIndex = nonPalmBeachIds.indexOf(countyId);
                return otherColors[colorIndex % otherColors.length];
            }
            
            if (comparisonChartInstance) {
                comparisonChartInstance.destroy();
            }
            
            const datasets = Object.entries(chartData).map(([countyId, series]) => {
                const color = getCountyColor(countyId);
                const countyName = countyNames[countyId] || `County ${countyId}`;
                const seriesPoints = Array.isArray(series) ? series : (series && Array.isArray(series.points) ? series.points : []);
                
                return {
                    label: countyName.replace(' County', ''),
                    data: seriesPoints.map(point => ({
                        x: point?.x,
                        y: (point?.y === null || point?.y === undefined || isNaN(point?.y)) ? null : point.y
                    })),
                    backgroundColor: color + '20',
                    borderColor: color,
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointBackgroundColor: color,
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    pointHoverBackgroundColor: color,
                    pointHoverBorderColor: '#ffffff',
                    clip: 0
                };
            });
            
            console.debug('County chart datasets', {
                title,
                seriesOption,
                datasetCount: datasets.length,
                samples: datasets.map(ds => ({
                    label: ds.label,
                    points: ds.data.slice(0, 5)
                }))
            });
            
            const ctx = canvas.getContext('2d');
            
            // Compute y padding so series do not hug edges
            const flatValues = datasets.flatMap(ds => (ds.data || []).map(d => d && d.y).filter(v => v != null && !isNaN(v)));
            const yMin = flatValues.length ? Math.min(...flatValues) : 0;
            const yMax = flatValues.length ? Math.max(...flatValues) : 1;
            const yPad = (yMax - yMin) * 0.08;
            const suggestedMin = Math.max(0, yMin - yPad);
            const suggestedMax = yMax + yPad * 0.5;

            // Create Chart.js configuration
            const config = {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { left: 16, right: 16, top: 8, bottom: 12 } },
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: '#333'
                        },
                        legend: {
                            display: true,
                            position: 'right',
                            labels: {
                                usePointStyle: false,
                                boxWidth: 14,
                                boxHeight: 4,
                                font: {
                                    size: 11
                                },
                                color: '#333'
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(tooltipItems) {
                                    const date = new Date(tooltipItems[0].parsed.x);
                                    return date.toLocaleDateString();
                                },
                                label: function(context) {
                                    return `${context.dataset.label}: ${formatMetricValue(context.parsed.y, seriesOption)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM yyyy'
                                }
                            },
                            offset: true,
                            grid: {
                                display: true,
                                color: '#f0f0f0'
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    size: 11
                                }
                            }
                        },
                        y: Object.assign({
                            grid: {
                                display: true,
                                color: '#f0f0f0'
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    return formatMetricValue(value, seriesOption);
                                }
                            }
                        }, computeYAxisConfig(seriesOption, datasets))
                    },
                    interaction: {
                        intersect: false
                    },
                    elements: {
                        line: {
                            tension: 0.4
                        },
                        point: {
                            radius: (window.innerWidth <= 768 ? 0 : 3),
                            hitRadius: (window.innerWidth <= 768 ? 4 : 6),
                            hoverRadius: (window.innerWidth <= 768 ? 0 : 4)
                        }
                    }
                }
            };

            // Create the chart and store the instance
            comparisonChartInstance = new Chart(ctx, config);
        }
        
        // Display professional notice for unavailable data series
        function displayDataAvailabilityNotice(unavailableLocations, seriesName) {
            const noticeContainer = document.getElementById('data-availability-notice');
            
            if (unavailableLocations.length === 0) {
                noticeContainer.style.display = 'none';
                return;
            }
            
            const locationsList = unavailableLocations.map(location => 
                `<li>${location.name}</li>`
            ).join('');
            
            const pluralText = unavailableLocations.length === 1 ? 'location' : 'locations';
            const verbText = unavailableLocations.length === 1 ? 'is' : 'are';
            
            noticeContainer.innerHTML = `
                <div class="data-notice-header">
                    <svg class="data-notice-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <h4 class="data-notice-title">Data Availability Notice</h4>
                </div>
                <p class="data-notice-content">
                    The <strong>${seriesName}</strong> indicator ${verbText} currently unavailable for the following ${pluralText}. 
                    This may be due to data collection schedules or regional reporting variations. 
                    The analysis above reflects all available data sources.
                </p>
                <ul class="unavailable-locations">
                    ${locationsList}
                </ul>
            `;
            
            noticeContainer.style.display = 'block';
        }
        
        // Populate the chart view series selector with the same options as the main selector
        function populateChartSeriesSelector() {
            const mainSeriesSelect = document.getElementById('series-select');
            const chartSeriesSelect = document.getElementById('chart-series-select');
            
            if (!mainSeriesSelect || !chartSeriesSelect) {
                console.error('Series select elements not found');
                return;
            }
            
            chartSeriesSelect.innerHTML = '<option value="">Select Indicator...</option>';
            REALTOR_METRICS.forEach(metric => {
                const opt = document.createElement('option');
                opt.value = metric.key;
                opt.textContent = metric.label;
                chartSeriesSelect.appendChild(opt);
            });
            chartSeriesSelect.value = mainSeriesSelect.value && realtorSeriesKeys.has(mainSeriesSelect.value)
                ? mainSeriesSelect.value
                : DEFAULT_COUNTY_METRIC;
        }
        // Handle indicator change in chart view - refresh the chart with new indicator
        async function refreshChartWithNewIndicator() {
            const chartSeriesSelect = document.getElementById('chart-series-select');
            const selectedSeries = chartSeriesSelect.value;
            
            if (!selectedSeries || !seriesOptionsCache) {
                return;
            }
            
            // Also update the main series selector to keep them in sync
            const mainSeriesSelect = document.getElementById('series-select');
            if (mainSeriesSelect) {
                mainSeriesSelect.value = selectedSeries;
            }
            
            // Get current location selections (they should still be available from the previous generation)
            const selections = [];
            
            for (let i = 1; i <= selectionCount; i++) {
                const stateSelect = document.getElementById(`state-select-${i}`);
                const countySelect = document.getElementById(`county-select-${i}`);
                
                if (stateSelect && countySelect && stateSelect.value && countySelect.value) {
                    selections.push({
                        state: stateSelect.value,
                        county: countySelect.value,
                        countyName: countySelect.options[countySelect.selectedIndex].text
                    });
                }
            }
            
            if (selections.length === 0) {
                console.error('No location selections found for chart refresh');
                return;
            }
            
            // Save the new comparison data
            await saveComparisonData(selectedSeries, selections);
            
            // Show loading state
            document.getElementById('chart-loading').style.display = 'flex';
            document.getElementById('chart-error').style.display = 'none';
            if (comparisonChartInstance) {
                comparisonChartInstance.destroy();
                comparisonChartInstance = null;
            }
            
            try {
                const seriesOption = seriesOptionsCache[selectedSeries];
                if (!seriesOption) {
                    alert('Selected metric is not available. Please choose another option.');
                    return;
                }
                const chartData = {};
                const countyNames = {};
                const unavailableLocations = [];

                const countyData = await fetchCountySeriesData(selections.map(sel => sel.county), selectedSeries);
                countyData.forEach(({ county, name, points }) => {
                    chartData[county] = points;
                    countyNames[county] = name;
                });
                selections.forEach(sel => {
                    if (!chartData[sel.county]) {
                        unavailableLocations.push({ name: sel.countyName, seriesId: selectedSeries });
                    }
                });

                document.getElementById('chart-loading').style.display = 'none';

                if (Object.keys(chartData).length === 0) {
                    document.getElementById('chart-error').style.display = 'flex';
                    document.getElementById('comparison-chart-header').style.display = 'none';
                    return;
                }

                document.getElementById('comparison-chart-header').style.display = 'block';
                createSimpleComparisonChart(chartData, countyNames, seriesOption.label, seriesOption);

                if (unavailableLocations.length > 0) {
                    displayDataAvailabilityNotice(unavailableLocations, seriesOption.label);
                } else {
                    // Hide the notice if all data is available
                    document.getElementById('data-availability-notice').style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error refreshing chart with new indicator:', error);
                document.getElementById('chart-loading').style.display = 'none';
                document.getElementById('chart-error').style.display = 'flex';
            }
        }
        
        // Map functionality
        let map = null;
        let currentDevelopmentName = null;
        
        // Initialize map button click handler
        function initializeMapButton() {
            const mapButton = document.getElementById('mapButton');
            if (mapButton) {
                mapButton.addEventListener('click', openDevelopmentMap);
            }
        }
        
        // Open development map in modal
        async function openDevelopmentMap() {
            const modal = document.getElementById('mapModal');
            const loading = document.getElementById('mapLoading');
            const error = document.getElementById('mapError');
            const subtitle = document.getElementById('mapSubtitle');
            
            // Guard: disable map for out-of-state properties
            try {
                if (window.isOutOfState === true) {
                    showMapError('Map is available only for Florida properties.');
                    return;
                }
            } catch (_) {}
            
            // Get development name from current report data
            const reportData = getCurrentReportData();
            if (!reportData || !reportData.development) {
                showMapError('No development information available for this property.');
                return;
            }
            
            currentDevelopmentName = reportData.development.trim();
            subtitle.textContent = `Showing parcels for ${currentDevelopmentName}`;
            
            // Show modal and loading state
            modal.style.display = 'block';
            loading.style.display = 'flex';
            error.style.display = 'none';
            
            try {
                // Fetch parcel data
                const response = await fetch(`${API_BASE}/development-parcels/${encodeURIComponent(currentDevelopmentName)}`);
                const result = await response.json();
                
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Failed to load parcel data');
                }
                
                if (!result.data || !result.data.features || result.data.features.length === 0) {
                    throw new Error('No parcels found for this development');
                }
                
                // Initialize map
                await initializeMap(result.data);
                
            } catch (error) {
                console.error('Error loading development map:', error);
                showMapError(error.message);
            } finally {
                loading.style.display = 'none';
            }
        }
        // Initialize Leaflet map with parcel data
        async function initializeMap(geojsonData) {
            const mapContainer = document.getElementById('developmentMap');
            
            // Clear existing map
            if (map) {
                map.remove();
                map = null;
            }
            
            // Create new map
            map = L.map('developmentMap', {
                zoomControl: true,
                scrollWheelZoom: true
            });
            
            // Add tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            
            // Color mode state and helpers
            let colorMode = 'none';
            let valueThresholds = null; // used for price/value modes
            let valueMin = null;
            let valueMax = null;
            const COLOR_MAP = {
                gray: '#6c757d',
                yellow: '#FFD54F',
                green: '#2ECC71',
                blue: '#3498DB',
                red: '#E74C3C',
                orange: '#F39C12',
                darkGreen: '#006400',
                lightGreen: '#90EE90',
                purple: '#8E44AD'
            };

            function parseDateSafe(value) {
                if (!value) return null;
                let v = String(value).trim();
                if (!v) return null;
                // Normalize common formats: YYYYMMDD, MM/DD/YYYY, YYYY-MM-DD
                if (/^\d{8}$/.test(v)) {
                    // Assume YYYYMMDD
                    v = `${v.slice(0,4)}-${v.slice(4,6)}-${v.slice(6,8)}`;
                } else if (/^\d{1,2}\/\d{1,2}\/\d{2,4}$/.test(v)) {
                    const [m, d, y] = v.split('/');
                    const year = y.length === 2 ? `20${y}` : y;
                    v = `${year}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
                }
                const d = new Date(v);
                return isNaN(d.getTime()) ? null : d;
            }

            function monthsBetween(fromDate, toDate) {
                const years = toDate.getFullYear() - fromDate.getFullYear();
                const months = toDate.getMonth() - fromDate.getMonth();
                const total = years * 12 + months + (toDate.getDate() >= fromDate.getDate() ? 0 : -1);
                return total;
            }

            function currencyFormat(n) {
                return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(n);
            }

            function computeQuantileThresholds(values) {
                const nums = values.filter(v => typeof v === 'number' && !isNaN(v)).sort((a, b) => a - b);
                if (nums.length === 0) return null;
                function quantile(p) {
                    const idx = Math.floor((nums.length - 1) * p);
                    return nums[idx];
                }
                return {
                    q50: quantile(0.50),
                    q75: quantile(0.75),
                    q85: quantile(0.85),
                    q95: quantile(0.95)
                };
            }

            function colorByTaxSaleDate(props) {
                const now = new Date();
                const d = parseDateSafe(props.last_sale_date);
                if (!d) return COLOR_MAP.gray;
                const m = monthsBetween(d, now);
                if (m < 6) return COLOR_MAP.yellow;
                if (m < 12) return COLOR_MAP.green;
                if (m < 24) return COLOR_MAP.blue;
                if (m < 60) return COLOR_MAP.red;
                return COLOR_MAP.orange; // 5+ years
            }

            function colorBySoldSinceCovid(props) {
                const d = parseDateSafe(props.last_sale_date);
                if (!d) return COLOR_MAP.gray;
                const covid = new Date('2020-01-01');
                return d >= covid ? COLOR_MAP.green : COLOR_MAP.gray;
            }

            function colorByValue(value) {
                if (value == null) return COLOR_MAP.gray;
                const num = typeof value === 'number' ? value : parseFloat(String(value).replace(/[$,]/g, ''));
                if (isNaN(num) || !valueThresholds) return COLOR_MAP.gray;
                const { q50, q75, q85, q95 } = valueThresholds;
                if (num >= q95) return COLOR_MAP.darkGreen;   // top 5%
                if (num >= q85) return COLOR_MAP.lightGreen;  // top 15%
                if (num >= q75) return COLOR_MAP.yellow;      // top 25%
                if (num >= q50) return COLOR_MAP.orange;      // top 50%
                return COLOR_MAP.red;                           // remaining
            }

            function colorByMlsStatus(props) {
                const status = (props.mls_status || '').toLowerCase();
                if (!status) return COLOR_MAP.gray;
                if (status === 'coming soon') return COLOR_MAP.purple;
                if (status === 'active') return COLOR_MAP.green;
                if (status === 'active under contract') return COLOR_MAP.orange;
                if (status === 'pending') return COLOR_MAP.blue;
                if (status === 'closed') {
                    // last 6 months yellow, older red
                    const sd = parseDateSafe(props.mls_sold_date);
                    if (!sd) return COLOR_MAP.gray;
                    const m = monthsBetween(sd, new Date());
                    return m <= 6 ? COLOR_MAP.yellow : COLOR_MAP.red;
                }
                return COLOR_MAP.gray;
            }

            function defaultLandUseStyle(props) {
                const landUse = (props.land_use_description || '').toString();
                const isCondo = landUse.toUpperCase().includes('CONDOMINIUM');
                return {
                    color: isCondo ? COLOR_MAP.purple : '#3498db',
                    weight: 2,
                    fillColor: isCondo ? COLOR_MAP.purple : '#3498db',
                    fillOpacity: 0.6
                };
            }

            function computeStyleByMode(props) {
                if (colorMode === 'none') {
                    return defaultLandUseStyle(props);
                }
                let outline = '#333';
                let fill = COLOR_MAP.blue;
                switch (colorMode) {
                    case 'tax_sale_date':
                        fill = colorByTaxSaleDate(props);
                        break;
                    case 'tax_sale_price':
                        fill = colorByValue(parseFloat(props.last_sale_price));
                        break;
                    case 'tax_market_value':
                        fill = colorByValue(parseFloat(props.market_value));
                        break;
                    case 'sold_since_covid':
                        fill = colorBySoldSinceCovid(props);
                        break;
                    case 'mls_status':
                        fill = colorByMlsStatus(props);
                        break;
                    default:
                        break;
                }
                return { color: outline, weight: 2, fillColor: fill, fillOpacity: 0.75 };
            }

            // Clean up any existing legend/control from prior sessions
            const parentEl = mapContainer.parentElement;
            const oldLegend = parentEl.querySelector('#mapLegend');
            if (oldLegend) { try { oldLegend.remove(); } catch(_) {} }
            const oldControl = parentEl.querySelector('#colorModeControl');
            if (oldControl) { try { oldControl.remove(); } catch(_) {} }

            // Legend UI
            const legend = document.createElement('div');
            legend.id = 'mapLegend';
            legend.style.position = 'absolute';
            legend.style.bottom = '16px';
            legend.style.right = '16px';
            legend.style.background = 'rgba(255,255,255,0.95)';
            legend.style.border = '1px solid #dee2e6';
            legend.style.borderRadius = '8px';
            legend.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
            legend.style.padding = '12px 14px';
            legend.style.minWidth = '220px';
            legend.style.fontSize = '12px';
            legend.style.zIndex = '1200';
            legend.innerHTML = '';
            parentEl.appendChild(legend);

            function renderLegend() {
                function swatch(color, label) {
                    return `<div style="display:flex;align-items:center;gap:8px;margin:4px 0;">
                        <span style="display:inline-block;width:14px;height:14px;background:${color};border:1px solid #999;border-radius:3px;"></span>
                        <span>${label}</span>
                    </div>`;
                }

                if (colorMode === 'none') {
                    legend.innerHTML = '';
                    return;
                }

                if (colorMode === 'tax_sale_date') {
                    legend.innerHTML = `
                        <div style="font-weight:600;margin-bottom:6px;">Legend: Tax Last Sale Date</div>
                        ${swatch(COLOR_MAP.yellow, 'Less than 6 months')}
                        ${swatch(COLOR_MAP.green, '6 months to 1 year')}
                        ${swatch(COLOR_MAP.blue, '1 to 2 years')}
                        ${swatch(COLOR_MAP.red, '2 to 5 years')}
                        ${swatch(COLOR_MAP.orange, 'More than 5 years')}
                        ${swatch(COLOR_MAP.gray, 'No data')}
                    `;
                } else if (colorMode === 'sold_since_covid') {
                    const features = (geojsonData && geojsonData.features) ? geojsonData.features : [];
                    const totalCount = features.length;
                    let yesCount = 0;
                    for (let i = 0; i < features.length; i++) {
                        const props = features[i] && features[i].properties ? features[i].properties : {};
                        const d = parseDateSafe(props.last_sale_date);
                        if (d && d >= new Date('2020-01-01')) yesCount++;
                    }
                    const noCount = Math.max(0, totalCount - yesCount);
                    const pct = (n) => totalCount > 0 ? (Math.round((n / totalCount) * 1000) / 10).toFixed(1) : '0.0';
                    legend.innerHTML = `
                        <div style="font-weight:600;margin-bottom:6px;">Legend: Sold Since Covid</div>
                        ${swatch(COLOR_MAP.green, `Sold since Covid — ${yesCount} (${pct(yesCount)}%)`)}
                        ${swatch(COLOR_MAP.gray, `Not sold since Covid — ${noCount} (${pct(noCount)}%)`)}
                    `;
                } else if (colorMode === 'tax_sale_price' || colorMode === 'tax_market_value') {
                    if (!valueThresholds || valueMin == null || valueMax == null) { legend.innerHTML = ''; return; }
                    const { q50, q75, q85, q95 } = valueThresholds;
                    const range = (a, b) => `${currencyFormat(a)} - ${currencyFormat(b)}`;
                    legend.innerHTML = `
                        <div style="font-weight:600;margin-bottom:6px;">Legend: ${colorMode === 'tax_sale_price' ? 'Tax Last Sale Price' : 'Tax Market Value'}</div>
                        ${swatch(COLOR_MAP.darkGreen, range(q95, valueMax))}
                        ${swatch(COLOR_MAP.lightGreen, range(q85, q95))}
                        ${swatch(COLOR_MAP.yellow, range(q75, q85))}
                        ${swatch(COLOR_MAP.orange, range(q50, q75))}
                        ${swatch(COLOR_MAP.red, range(valueMin, q50))}
                        ${swatch(COLOR_MAP.gray, 'No data')}
                    `;
                } else if (colorMode === 'mls_status') {
                    legend.innerHTML = `
                        <div style="font-weight:600;margin-bottom:6px;">Legend: MLS Status</div>
                        ${swatch(COLOR_MAP.green, 'Active')}
                        ${swatch(COLOR_MAP.orange, 'Active Under Contract')}
                        ${swatch(COLOR_MAP.yellow, 'Closed (Last 6 months)')}
                        ${swatch(COLOR_MAP.red, 'Closed (Older)')}
                        ${swatch(COLOR_MAP.purple, 'Coming Soon')}
                        ${swatch(COLOR_MAP.blue, 'Pending')}
                        ${swatch(COLOR_MAP.gray, 'No Data')}
                    `;
                } else {
                    legend.innerHTML = '';
                }
            }

            function recomputeThresholdsIfNeeded(features) {
                if (colorMode === 'tax_sale_price') {
                    const vals = features.map(f => parseFloat(String(f.properties.last_sale_price || '').toString().replace(/[$,]/g, ''))).filter(v => !isNaN(v));
                    valueThresholds = computeQuantileThresholds(vals);
                    if (vals.length > 0) { valueMin = Math.min(...vals); valueMax = Math.max(...vals); } else { valueMin = valueMax = null; }
                } else if (colorMode === 'tax_market_value') {
                    const vals = features.map(f => parseFloat(String(f.properties.market_value || '').toString().replace(/[$,]/g, ''))).filter(v => !isNaN(v));
                    valueThresholds = computeQuantileThresholds(vals);
                    if (vals.length > 0) { valueMin = Math.min(...vals); valueMax = Math.max(...vals); } else { valueMin = valueMax = null; }
                } else {
                    valueThresholds = null; valueMin = valueMax = null;
                }
            }

            function updateParcelStyles() {
                parcelLayer.eachLayer(function(layer) {
                    const props = layer.feature.properties;
                    const style = computeStyleByMode(props);
                    layer.setStyle(style);
                });
                renderLegend();
            }

            // Add parcel polygons
            const parcelLayer = L.geoJSON(geojsonData, {
                style: function(feature) {
                    return computeStyleByMode(feature.properties);
                },
                onEachFeature: function(feature, layer) {
                    // Create popup content using tax record template
                    const props = feature.properties;
                    const landUse = props.land_use_description || '';
                    const isCondominium = landUse.toUpperCase().includes('CONDOMINIUM');
                    
                    let popupContent;
                    
                    if (isCondominium) {
                        // Simplified popup for condominiums - subdivision info (no MLS waterfrontage shown)
                        popupContent = `
                            <div style="min-width: 280px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.4;">
                                <div style="margin-bottom: 8px; font-size: 16px; font-weight: 600; color: #8e44ad;">Condominium Building</div>
                                <div style="margin-bottom: 8px;"><strong>Development:</strong> ${props.development_name || 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Subdivision:</strong> ${props.subdivision_name || 'N/A'}</div>
                        `;
                        
                        // Add unit count info
                        if (props.unit_count && props.unit_count > 1) {
                            popupContent += `<div style="margin-top: 12px; padding: 8px; background-color: #f8f4ff; border-left: 3px solid #8e44ad; font-size: 12px; color: #666;">
                                <strong>Building Info:</strong> This building contains ${props.unit_count} condominium units
                            </div>`;
                        }
                        
                        popupContent += '</div>';
                    } else {
                        // Full popup for non-condominium properties
                        
                        // Format address
                        let address = 'N/A';
                        if (props.address) {
                            let fullAddress = props.address;
                            if (props.city) fullAddress += ` ${props.city}`;
                            if (props.zip_code) fullAddress += `, FL ${props.zip_code}`;
                            address = fullAddress;
                        }
                        
                        // Format market value
                        let marketValue = 'N/A';
                        if (props.market_value) {
                            marketValue = new Intl.NumberFormat('en-US', {
                                style: 'currency',
                                currency: 'USD',
                                minimumFractionDigits: 0
                            }).format(props.market_value);
                        }
                        
                        // Format last sale price
                        let lastSalePrice = 'N/A';
                        if (props.last_sale_price) {
                            lastSalePrice = new Intl.NumberFormat('en-US', {
                                style: 'currency',
                                currency: 'USD',
                                minimumFractionDigits: 0
                            }).format(props.last_sale_price);
                        }
                        
                        // Format bathrooms (convert to numbers to remove leading zeros)
                        let bathrooms = 'N/A';
                        if (props.full_baths || props.half_baths) {
                            const full = parseInt(props.full_baths) || 0;
                            const half = parseInt(props.half_baths) || 0;
                            if (half > 0) {
                                bathrooms = `${full} full, ${half} half`;
                            } else {
                                bathrooms = `${full} full`;
                            }
                        }
                        
                        popupContent = `
                            <div style="min-width: 280px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.4;">
                                <div style="margin-bottom: 8px;"><strong>Address:</strong> ${address}</div>
                                <div style="margin-bottom: 8px;"><strong>Parcel ID:</strong> ${props.property_control_number || 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Year Built:</strong> ${props.year_built || 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Development:</strong> ${props.development_name || 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Subdivision:</strong> ${props.subdivision_name || 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Bedrooms:</strong> ${props.bedrooms ? parseInt(props.bedrooms) : 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Bathrooms:</strong> ${bathrooms}</div>
                                <div style="margin-bottom: 8px;"><strong>Market Value:</strong> <span style="color: #27ae60; font-weight: 600;">${marketValue}</span></div>
                                <div style="margin-bottom: 8px;"><strong>Last Sale Date:</strong> ${props.last_sale_date || 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Last Sale Price:</strong> ${lastSalePrice}</div>
                                <div style="margin-bottom: 0;"><strong>Waterfrontage (MLS):</strong> ${props.waterfrontage || 'N/A'}</div>
                        `;
                        
                        // Add unit count info for multi-unit buildings
                        if (props.unit_count && props.unit_count > 1) {
                            popupContent += `<div style="margin-top: 12px; padding: 8px; background-color: #f8f9fa; border-left: 3px solid #3498db; font-size: 12px; color: #666;">
                                <strong>Building Info:</strong> This building contains ${props.unit_count} units
                            </div>`;
                        }
                        
                        popupContent += '</div>';
                    }
                    
                    layer.bindPopup(popupContent);
                    
                    // Add hover effects
                    layer.on('mouseover', function() {
                        this.setStyle({
                            weight: 3,
                            fillOpacity: 0.9
                        });
                    });
                    
                    layer.on('mouseout', function() {
                        // Restore style based on current mode
                        this.setStyle(computeStyleByMode(this.feature.properties));
                    });
                }
            }).addTo(map);
            
            // Fit map to parcel bounds
            map.fitBounds(parcelLayer.getBounds(), {
                padding: [20, 20]
            });

            // Create color mode selector UI
            const selectorWrap = document.createElement('div');
            selectorWrap.id = 'colorModeControl';
            selectorWrap.style.position = 'absolute';
            selectorWrap.style.top = '16px';
            selectorWrap.style.right = '16px';
            selectorWrap.style.background = 'rgba(255,255,255,0.95)';
            selectorWrap.style.border = '1px solid #dee2e6';
            selectorWrap.style.borderRadius = '8px';
            selectorWrap.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
            selectorWrap.style.padding = '8px 12px';
            selectorWrap.style.zIndex = '1200';
            selectorWrap.style.display = 'flex';
            selectorWrap.style.gap = '8px';
            selectorWrap.style.alignItems = 'center';

            const select = document.createElement('select');
            select.id = 'colorModeSelect';
            select.style.fontSize = '12px';
            select.style.padding = '6px 8px';
            select.style.border = '1px solid #ced4da';
            select.style.borderRadius = '6px';
            select.style.background = '#fff';

            const options = [
                { value: 'none', label: 'View Metric' },
                { value: 'tax_sale_date', label: 'Tax Last Sale Date' },
                { value: 'tax_sale_price', label: 'Tax Last Sale Price' },
                { value: 'tax_market_value', label: 'Tax Market Value' },
                { value: 'sold_since_covid', label: 'Sold Since Covid' },
                { value: 'mls_status', label: 'MLS Status' }
            ];
            options.forEach(opt => {
                const o = document.createElement('option');
                o.value = opt.value;
                o.textContent = opt.label;
                select.appendChild(o);
            });
            select.value = colorMode;

            select.addEventListener('change', function() {
                colorMode = this.value;
                recomputeThresholdsIfNeeded(geojsonData.features);
                updateParcelStyles();
            });

            selectorWrap.appendChild(select);
            parentEl.appendChild(selectorWrap);

            // Initial thresholds + legend render
            recomputeThresholdsIfNeeded(geojsonData.features);
            renderLegend();
        }
        
        // Get status color for styling
        function getStatusColor(status) {
            if (!status) return '#6c757d';
            
            const statusLower = status.toLowerCase();
            if (statusLower.includes('active')) return '#e74c3c';
            if (statusLower.includes('sold') || statusLower.includes('closed')) return '#27ae60';
            if (statusLower.includes('pending') || statusLower.includes('contract')) return '#f39c12';
            return '#6c757d';
        }
        
        // Show map error
        function showMapError(message) {
            const modal = document.getElementById('mapModal');
            const loading = document.getElementById('mapLoading');
            const error = document.getElementById('mapError');
            const errorMessage = document.getElementById('mapErrorMessage');
            
            modal.style.display = 'block';
            loading.style.display = 'none';
            error.style.display = 'flex';
            errorMessage.textContent = message;
        }
        // Get current report data
        function getCurrentReportData() {
            // Prefer inferred development from lookup or current selection
            try {
                if (window._inferredDevelopment && String(window._inferredDevelopment).trim().length > 0) {
                    return { development: String(window._inferredDevelopment).trim() };
                }
            } catch {}
            try {
                if (typeof currentDevelopmentName === 'string' && currentDevelopmentName.trim().length > 0) {
                    return { development: currentDevelopmentName.trim() };
                }
            } catch {}
            // Fallback: try to extract development from the styled address block
            const developmentElement = document.querySelector('#propertyAddress');
            if (developmentElement) {
                // Try to extract development name from the styled address
                const addressHtml = developmentElement.innerHTML;
                const italicMatches = addressHtml.match(/<div[^>]*font-style:\s*italic[^>]*>([^<]+)<\/div>/g);
                if (italicMatches && italicMatches.length > 0) {
                    // Get the first italic line (development)
                    const developmentMatch = italicMatches[0].match(/>([^<]+)</);
                    if (developmentMatch) {
                        return { development: developmentMatch[1].trim() };
                    }
                }
            }
            
            // Fallback: return null if no development found
            return null;
        }
        
        // Close map modal
        function closeMapModal() {
            const modal = document.getElementById('mapModal');
            modal.style.display = 'none';
            
            // Clean up map
            if (map) {
                map.remove();
                map = null;
            }

            // Reset color mode UI and legend to avoid sticky state
            try {
                const container = document.getElementById('developmentMap');
                const parentEl = container ? container.parentElement : null;
                if (parentEl) {
                    const oldLegend = parentEl.querySelector('#mapLegend');
                    if (oldLegend) oldLegend.remove();
                    const oldControl = parentEl.querySelector('#colorModeControl');
                    if (oldControl) oldControl.remove();
                }
            } catch (_) {}
        }
        
        // Initialize map modal close handler
        function initializeMapModal() {
            const closeButton = document.getElementById('closeMapModal');
            if (closeButton) {
                closeButton.addEventListener('click', closeMapModal);
            }
            
            // Close modal when clicking outside
            const modal = document.getElementById('mapModal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeMapModal();
                    }
                });
            }
            
            // Close modal with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && modal.style.display === 'block') {
                    closeMapModal();
                }
            });
        }
        
        // Global function to update counties (called from inline onchange)
        window.updateCounties = updateCounties;
        
        // Load report on page load
        loadReport();
        
        // Initialize map functionality
        initializeMapButton();
        
        // Initialize map modal after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeMapModal();
        });
        
        // Also try initializing immediately in case DOMContentLoaded already fired
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeMapModal);
        } else {
            // DOM is already loaded
            setTimeout(initializeMapModal, 100);
        }
        
        // Initialize FRED comparison after report loads
        function waitForElements() {
            const seriesSelect = document.getElementById('series-select');
            if (seriesSelect) {
                initializeFredComparison();
            } else {
                console.log('Waiting for FRED elements to load...');
                setTimeout(waitForElements, 500);
            }
        }
        setTimeout(waitForElements, 1000);

        // API base path (supports reverse-proxy /report prefix)
        // Already defined at top; reuse to avoid redeclaration
        // const API_BASE = window.location.pathname.startsWith('/report/') ? '/report/api' : '/api';

        // Development/Zone Comparison Functionality
        let selectionMode = 'development'; // 'development' | 'zone'
        // Maintain independent selections for developments and zones
        window.selectedDevelopments = window.selectedDevelopments || [];
        window.selectedZones = window.selectedZones || [];
        // Track last mouse position as a reliable fallback for popup placement
        (function trackLastMousePosition(){
            try {
                window.__lastMouse = { x: 0, y: 0 };
                document.addEventListener('mousemove', function(e){
                    if (e && typeof e.clientX === 'number' && typeof e.clientY === 'number') {
                        window.__lastMouse.x = e.clientX;
                        window.__lastMouse.y = e.clientY;
                    }
                }, { passive: true });
            } catch (err) {
                console.warn('Unable to attach mousemove listener for popup placement fallback:', err);
            }
        })();

        let developmentSelectionCount = 1;
        let developmentsList = [];
        let zonesList = [];
        let __suppressNextDocumentClick = false;

        // Helper: Try direct-render neighbourhood from complete endpoint (fallback)
        async function tryRenderFromComplete(slug) {
            try {
                const resp = await fetch(`${API_BASE}/reports/complete/${slug}`);
                if (!resp.ok) return false;
                const json = await resp.json();
                const charts = json && json.data && Array.isArray(json.data.charts) ? json.data.charts : [];
                const saved = charts.find(c => c && (c.chart_type === 'neighbourhood_comparison' || c.chart_type === 'neighborhood_comparison'));
                if (!saved || !Array.isArray(saved.locations) || saved.locations.length === 0) return false;

        const selections = saved.locations;
        // Attempt to split types from saved payload if available, else treat all as developments for fetch but keep labels distinct
        const devs = Array.isArray(saved.development_names) ? saved.development_names : selections;
        const zones = Array.isArray(saved.zone_names) ? saved.zone_names : [];

        // Fetch both types where possible
        const reqs = [];
        if (Array.isArray(devs) && devs.length > 0) {
            reqs.push(fetch(`${API_BASE}/developments-comparison?developments=${encodeURIComponent(devs.join(','))}`));
        }
        if (Array.isArray(zones) && zones.length > 0) {
            reqs.push(fetch(`${API_BASE}/zones-comparison?zones=${encodeURIComponent(zones.join(','))}`));
        }
        const resps = await Promise.all(reqs);
        const jsons = await Promise.all(resps.map(r => r.ok ? r.json() : Promise.resolve(null)));
        let merged = [];
        jsons.forEach(j => {
            if (!j || !j.success) return;
            if (Array.isArray(j.data)) merged.push(...j.data);
            else if (Array.isArray(j.data?.comparisonData)) merged.push(...j.data.comparisonData);
        });

        // Build labels and mappings
        const devSetLower = new Set((devs || []).map(n => String(n).toLowerCase()));
        const overlapLower = new Set((zones || []).map(n => String(n).toLowerCase()).filter(n => devSetLower.has(n)));
        const entityLabelMap = {};
        const entityKeyToLabel = {};
        const labels = [];
        (devs || []).forEach(name => {
            const label = String(name);
            labels.push(label);
            entityLabelMap[label] = { name: String(name), type: 'development' };
            entityKeyToLabel[`development:${String(name).toLowerCase()}`] = label;
        });
        (zones || []).forEach(name => {
            const lower = String(name).toLowerCase();
            const label = overlapLower.has(lower) ? `${name} (Zone)` : String(name);
            labels.push(label);
            entityLabelMap[label] = { name: String(name), type: 'zone' };
            entityKeyToLabel[`zone:${lower}`] = label;
        });
        window.entityLabelMap = entityLabelMap;
        window.entityKeyToLabel = entityKeyToLabel;

        displayDevelopmentComparisonChart(merged, labels);
                showDevelopmentChartView();
                const chartControls = document.getElementById('development-chart-controls');
                if (chartControls) chartControls.style.display = 'block';
                const chartHeader = document.getElementById('dev-comparison-chart-header');
                if (chartHeader) chartHeader.style.display = 'block';
                // Restore chart type (no auto-regenerate)
                if (saved.series_id) {
                    const type = String(saved.series_id);
                    if (type === 'sales' || type === 'price' || type === 'price_per_sqft') {
                        switchDevelopmentChart(type);
                    }
                }
                return true;
            } catch (e) {
                console.warn('tryRenderFromComplete failed:', e);
                return false;
            }
        }
        let countyInsightsChart = null;
        async function initCountyInsights(reportData) {
            try {
                let zipFromReport = String(reportData.__zipFallback || reportData.zip_code || '').trim();
                if (!/^\d{5}$/.test(zipFromReport)) {
                    zipFromReport = '33477';
                }

                const metricSelect = document.getElementById('county-insights-metric-select');
                metricSelect.innerHTML = '';
                REALTOR_METRICS.forEach(metric => {
                    const option = document.createElement('option');
                    option.value = metric.key;
                    option.textContent = metric.label;
                    metricSelect.appendChild(option);
                });

                const chartSection = document.getElementById('county-insights');
                const loadingEl = document.getElementById('county-insights-loading');
                const errorEl = document.getElementById('county-insights-error');

                const ciLocations = document.getElementById('ci-location-selections');
                const ciAddBtn = document.getElementById('ci-add-location-btn');
                const ciRemoveBtn = document.getElementById('ci-remove-location-btn');
                const ciCompareBtn = document.getElementById('ci-compare-btn');
                window.ciSelectionCount = 1;

                function selectedZips() {
                    const list = [];
                    for (let i = 1; i <= (window.ciSelectionCount || 1); i++) {
                        const input = document.getElementById(`ci-zip-input-${i}`);
                        if (input && input.value && /^\d{5}$/.test(input.value.trim())) {
                            list.push({ zip: input.value.trim(), name: input.value.trim() });
                        }
                    }
                    return list;
                }

                function ciShowControlsView() {
                    document.getElementById('ci-controls-section').style.display = 'block';
                    document.getElementById('ci-chart-controls').style.display = 'none';
                    document.getElementById('county-insights-chart-container').style.display = 'none';
                }
                function ciShowChartView() {
                    document.getElementById('ci-controls-section').style.display = 'none';
                    document.getElementById('ci-chart-controls').style.display = 'block';
                    document.getElementById('county-insights-chart-container').style.display = 'block';
                }

                function formatCityState(city, state) {
                    try {
                        const rawCity = String(city || '').trim();
                        const rawState = String(state || '').trim();
                        const state2 = rawState.length === 2
                            ? rawState.toUpperCase()
                            : (rawState ? rawState.split(/\s+/).map(p => p[0]?.toUpperCase()).join('') : '');

                        // Remove any trailing ", <state>" already present in city (e.g., "Jupiter, fl")
                        let cityClean = rawCity;
                        if (state2) {
                            const reAbbr = new RegExp(`\\s*,\\s*${state2}$`, 'i');
                            cityClean = cityClean.replace(reAbbr, '');
                        }
                        if (rawState) {
                            const reFull = new RegExp(`\\s*,\\s*${rawState}$`, 'i');
                            cityClean = cityClean.replace(reFull, '');
                        }
                        // Generic cleanup: strip any trailing ", XX"
                        cityClean = cityClean.replace(/,\s*[A-Za-z]{2}\s*$/, '');

                        // Title-case city
                        const titled = cityClean.replace(/\b([A-Za-zÀ-ÖØ-öø-ÿ])(\S*)/g, (_m, a, b) => a.toUpperCase() + b.toLowerCase());

                        // Append state if not already present
                        if (state2 && !new RegExp(`,\\s*${state2}$`, 'i').test(titled)) {
                            return `${titled}, ${state2}`;
                        }
                        return titled;
                    } catch { return city || ''; }
                }

                async function rebuildCiSelections() {
                    const prev = [];
                    for (let i = 1; i <= (window.ciSelectionCount || 1); i++) {
                        const input = document.getElementById(`ci-zip-input-${i}`);
                        if (input) prev.push(input.value.trim());
                    }
                    ciLocations.innerHTML = '';
                    for (let i = 1; i <= (window.ciSelectionCount || 1); i++) {
                        const wrap = document.createElement('div');
                        wrap.className = 'location-selection';
                        wrap.id = `ci-location-${i}`;
                        wrap.innerHTML = `
                            <div>
                                <label>ZIP or City</label>
                                <input id="ci-zip-input-${i}" type="text" placeholder="Enter ZIP or City, ST" maxlength="64" style="width: 200px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;" />
                            </div>
                            <div>
                                <label id="ci-zip-dropdown-label-${i}" style="display:none;">Select ZIP</label>
                                <select id="ci-zip-dropdown-${i}" style="display:none; min-width: 220px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; background:white;"></select>
                            </div>
                        `;
                        ciLocations.appendChild(wrap);
                        const input = document.getElementById(`ci-zip-input-${i}`);
                        const dropdown = document.getElementById(`ci-zip-dropdown-${i}`);
                        const dropdownLabel = document.getElementById(`ci-zip-dropdown-label-${i}`);
                        if (prev[i-1]) {
                            input.value = prev[i-1];
                        } else if (Array.isArray(window.__savedZipCodes) && window.__savedZipCodes[i-1]) {
                            input.value = String(window.__savedZipCodes[i-1]).padStart(5, '0');
                        } else if (i === 1 && zipFromReport && /^\d{5}$/.test(zipFromReport)) {
                            input.value = zipFromReport;
                        }

                        let debounceTimer = null;
                        input.addEventListener('input', () => {
                            const val = String(input.value || '').trim();
                            if (/^\d{5}$/.test(val)) {
                                dropdown.style.display = 'none';
                                dropdownLabel.style.display = 'none';
                                return;
                            }
                            if (val.length < 2) {
                                dropdown.style.display = 'none';
                                dropdownLabel.style.display = 'none';
                                return;
                            }
                            if (debounceTimer) clearTimeout(debounceTimer);
                            debounceTimer = setTimeout(async () => {
                                try {
                                    const url = new URL(`${API_BASE}/zipcity/by-city`, window.location.origin);
                                    // Parse optional state hint like "City, ST" or "City, State Name"
                                    let cityQuery = val;
                                    let stateHint = null;
                                    const m = val.match(/^(.*?),(.*)$/);
                                    if (m) {
                                        cityQuery = m[1].trim();
                                        stateHint = m[2].trim();
                                    }
                                    url.searchParams.set('city', cityQuery);
                                    if (stateHint && stateHint.length > 0) {
                                        const two = stateHint.match(/^\s*([A-Za-z]{2})\s*$/);
                                        url.searchParams.set('state', two ? two[1].toUpperCase() : stateHint);
                                    }
                                    const resp = await fetch(url.toString().replace(window.location.origin, ''));
                                    const json = await resp.json();
                                    if (!resp.ok || !json.success) throw new Error('Lookup failed');
                                    const rows = Array.isArray(json.data) ? json.data : [];
                                    if (rows.length === 0) {
                                        dropdown.style.display = 'none';
                                        dropdownLabel.style.display = 'none';
                                        return;
                                    }
                                    dropdown.innerHTML = '<option value="">Select ZIP</option>';
                                    const seen = new Set();
                                    for (const r of rows) {
                                        const zip5 = String(r.zip5 || r.zip || '').padStart(5, '0');
                                        if (!/^\d{5}$/.test(zip5) || seen.has(zip5)) continue;
                                        seen.add(zip5);
                                        const opt = document.createElement('option');
                                        const stateDisp = r.state_id || r.state_name || '';
                                        opt.value = zip5;
                                        opt.textContent = `${zip5} - ${r.city || ''}${stateDisp ? ', ' + stateDisp : ''}`;
                                        dropdown.appendChild(opt);
                                    }
                                    if (dropdown.options.length > 1) {
                                        dropdown.style.display = 'inline-block';
                                        dropdownLabel.style.display = 'inline-block';
                                    } else {
                                        dropdown.style.display = 'none';
                                        dropdownLabel.style.display = 'none';
                                    }
                                } catch (_) {
                                    dropdown.style.display = 'none';
                                    dropdownLabel.style.display = 'none';
                                }
                            }, 400);
                        });
                        dropdown.addEventListener('change', () => {
                            const z = String(dropdown.value || '').trim();
                            if (/^\d{5}$/.test(z)) {
                                input.value = z;
                                dropdown.style.display = 'none';
                                dropdownLabel.style.display = 'none';
                            }
                        });
                    }
                    ciRemoveBtn.style.display = (window.ciSelectionCount || 1) > 1 ? 'inline-block' : 'none';
                }

                ciAddBtn.addEventListener('click', async () => {
                    window.ciSelectionCount = Math.min(5, (window.ciSelectionCount || 1) + 1);
                    await rebuildCiSelections();
                });
                ciRemoveBtn.addEventListener('click', async () => {
                    window.ciSelectionCount = Math.max(1, (window.ciSelectionCount || 1) - 1);
                    await rebuildCiSelections();
                });

                const fetchAndRender = async () => {
                    try {
                        console.debug('ZIP insights initial fetch start', { zipFromReport, apiBase: API_BASE });
                        chartSection.style.display = 'block';
                        loadingEl.style.display = 'flex';
                        errorEl.style.display = 'none';

                        let rows = null;
                        const url2 = new URL(`${API_BASE}/zip-series`, window.location.origin);
                        if (zipFromReport) url2.searchParams.set('zip', zipFromReport);
                        url2.searchParams.set('months', '36');
                        const resp2 = await fetch(url2.toString().replace(window.location.origin, ''));
                        const json2 = await resp2.json();
                        console.debug('ZIP insights initial API response', { status: resp2.status, success: json2.success, count: json2.data?.length, sample: json2.data?.slice?.(0, 5) });
                        if (!resp2.ok || !json2.success || !Array.isArray(json2.data) || json2.data.length === 0) {
                            throw new Error(json2.error || 'No data');
                        }
                        rows = json2.data.map(r => ({
                            zip5: String(r.zip5 || zipFromReport || '').padStart(5, '0'),
                            city: r.city || r.zip_name || r.county_name || '',
                            month_date_yyyymm: r.month_date_yyyymm || r.yyyymm,
                            avg_listing_price: r.avg_listing_price,
                            med_listing_price: r.median_listing_price,
                            median_listing_price_proxy: r.median_listing_price_proxy || r.median_listing_price,
                            median_days_on_market: r.avg_days_on_market || r.median_days_on_market,
                            avg_days_on_market: r.avg_days_on_market,
                            median_price_per_sqft: r.avg_price_per_sqft,
                            avg_price_per_sqft: r.avg_price_per_sqft,
                            active_listing_count: r.active_listing_count,
                            new_listing_count: r.new_listing_count,
                            pending_listing_count: r.pending_listing_count,
                            total_listing_count: r.total_listing_count,
                            pending_ratio: r.pending_ratio,
                            price_increased_share: r.price_increased_share,
                            price_reduced_share: r.price_reduced_share
                        }));

                        const metric = metricSelect.value || 'avg_listing_price';
                        const cityName = formatCityState(rows[0].city || '', rows[0].state_id || rows[0].state || rows[0].state_name);
                        const zipLabel = String(rows[0].zip5 || '').padStart(5, '0');
                        const title = `${metricLabel(metric)}`;
                        const effectiveMetric = (metric === 'med_listing_price' && rows[0].median_listing_price) ? 'median_listing_price' : metric;
                        const series = [{ key: effectiveMetric, label: `${zipLabel}${cityName ? ' - ' + cityName : ''}`, data: rows.map(r => ({ x: parseYyyymmToDate(r.month_date_yyyymm), y: toNumberOrNull(r[effectiveMetric]) })) }];
                        console.debug('ZIP insights initial dataset', { metric, effectiveMetric, series });
                        renderCountyInsightsChart(series, title);
                        ciShowChartView();
                        loadingEl.style.display = 'none';
                    } catch (err) {
                        console.warn('ZIP insights error:', err);
                        loadingEl.style.display = 'none';
                        errorEl.style.display = 'flex';
                    }
                };

                async function ciRenderForSelections(metric, selections) {
                    try {
                        console.debug('zip comparison request', { metric, selections });
                        chartSection.style.display = 'block';
                        loadingEl.style.display = 'flex';
                        errorEl.style.display = 'none';
                        const zipList = selections.map(s => s.zip).join(',');
                        const url = new URL(`${API_BASE}/zip-comparison`, window.location.origin);
                        url.searchParams.set('zips', zipList);
                        url.searchParams.set('months', '36');
                        const resp = await fetch(url.toString().replace(window.location.origin, ''));
                        const json = await resp.json();
                        console.debug('zip comparison API response', { status: resp.status, success: json.success, count: json.data?.length, sample: json.data?.slice?.(0, 5) });
                        if (!resp.ok || !json.success || !Array.isArray(json.data) || json.data.length === 0) throw new Error(json.error || 'No data');
                        const byZip = {}; const names = {};
                        for (const r of json.data) {
                            const id = String(r.zip5).padStart(5, '0');
                            if (!byZip[id]) byZip[id] = [];
                            byZip[id].push({ x: parseYyyymmToDate(r.month_date_yyyymm), y: toNumberOrNull(r[metric]) });
                            const city = r.city || '';
                            const state = r.state_id || r.state || r.state_name || '';
                            const disp = (city || state) ? formatCityState(city, state) : '';
                            names[id] = `${id}${disp ? ' - ' + disp : ''}`;
                        }
                        const series = Object.keys(byZip).map((id) => ({ key: metric, label: `${names[id]}`, data: byZip[id] }));
                        console.debug('zip comparison datasets', { metric, series });
                        renderCountyInsightsChart(series, metricLabel(metric));
                        ciShowChartView();
                        loadingEl.style.display = 'none';
                    } catch (e) {
                        console.warn('ZIP insights comparison error:', e);
                        loadingEl.style.display = 'none';
                        errorEl.style.display = 'flex';
                    }
                }

                function resolveZipReportId() {
                    try {
                        const candidates = [reportData?.report_id, reportData?.reportId, reportData?.id, reportData?.reportid];
                        for (const value of candidates) {
                            const num = Number(value);
                            if (Number.isFinite(num) && num > 0) return num;
                        }
                    } catch (_) {}
                    try {
                        if (typeof urlSlug === 'string' && urlSlug.length > 0) {
                            const m = urlSlug.match(/(\d+)/);
                            if (m) {
                                const num = Number(m[1]);
                                if (Number.isFinite(num) && num > 0) return num;
                            }
                        }
                    } catch (_) {}
                    return null;
                }
                function sanitizeZipList(list) {
                    return Array.isArray(list)
                        ? list.map(z => String(z || '').trim()).filter(z => /^\d{5}$/.test(z)).slice(0, 5)
                        : [];
                }
                async function loadSavedZipComparison() {
                    const reportId = resolveZipReportId();
                    if (!reportId) return null;
                    try {
                        const resp = await fetch(`${API_BASE}/reports/${reportId}/zip-comparison`);
                        const json = await resp.json();
                        if (!resp.ok || !json.success || !json.data) return null;
                        const zips = sanitizeZipList(json.data.zip_codes);
                        return { series_id: json.data.series_id || 'avg_listing_price', zip_codes: zips };
                    } catch (_) { return null; }
                }
                function applySavedZipComparison(saved) {
                    if (!saved || !Array.isArray(saved.zip_codes) || saved.zip_codes.length === 0) return;
                    if (saved.series_id && metricSelect.querySelector(`option[value="${saved.series_id}"]`)) {
                        metricSelect.value = saved.series_id;
                    }
                    try { window.__savedZipCodes = saved.zip_codes.slice(); } catch (_) {}
                    window.ciSelectionCount = Math.min(5, saved.zip_codes.length || 1);
                }
                async function saveZipComparison(metric, selections) {
                    const reportId = resolveZipReportId();
                    if (!reportId) return;
                    const payloadZips = sanitizeZipList((selections || []).map(s => s.zip));
                    if (payloadZips.length === 0) return;
                    try {
                        await fetch(`${API_BASE}/reports/${reportId}/zip-comparison`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ seriesId: metric || 'avg_listing_price', zipIds: payloadZips })
                        });
                    } catch (_) {}
                }

                metricSelect.addEventListener('change', async () => {
                    const selections = selectedZips();
                    const metric = metricSelect.value || 'avg_listing_price';
                    if (selections.length > 0) {
                        await ciRenderForSelections(metric, selections);
                        await saveZipComparison(metric, selections);
                    } else {
                        await fetchAndRender();
                    }
                });
                await rebuildCiSelections();
                const savedZipComparison = await loadSavedZipComparison();
                applySavedZipComparison(savedZipComparison);
                await rebuildCiSelections();
                if (savedZipComparison && Array.isArray(savedZipComparison.zip_codes) && savedZipComparison.zip_codes.length > 0) {
                    const metric = savedZipComparison.series_id || (metricSelect.value || 'avg_listing_price');
                    const selections = savedZipComparison.zip_codes.map(zip => ({ zip, label: zip }));
                    await ciRenderForSelections(metric, selections);
                } else {
                    await fetchAndRender();
                }
                ciCompareBtn.addEventListener('click', async () => {
                     const selections = selectedZips();
                     const metric = metricSelect.value || 'avg_listing_price';
                     if (selections.length > 0) {
                         await ciRenderForSelections(metric, selections);
                         await saveZipComparison(metric, selections);
                         try { window.__savedZipCodes = selections.map(s => String(s.zip || '').padStart(5,'0')); } catch (_) {}
                     } else if (zipFromReport) {
                         await fetchAndRender();
                     }
                 });
                 const ciBackBtn = document.getElementById('ci-back-to-controls-btn');
                 ciBackBtn.addEventListener('click', async () => {
                     ciShowControlsView();
                     try { await rebuildCiSelections(); } catch (_) {}
                 });
             } catch (e) {
                 console.warn('initCountyInsights failed:', e);
             }
         }
        function renderCountyInsightsChart(series, title) {
             const canvas = document.getElementById('county-insights-chart');
             if (!canvas) return;
             if (countyInsightsChart) {
                 countyInsightsChart.destroy();
                 countyInsightsChart = null;
             }
             const basePalette = ['#e83e8c', '#28a745', '#fd7e14', '#6f42c1', '#20c997', '#ffc107', '#6610f2', '#d63384', '#adb5bd'];
             const jupiterColor = '#003366';
             const isJupiterLabel = (label) => {
                 const text = String(label || '');
                 return /jupiter/i.test(text) && /\bfl\b/i.test(text);
             };
             let paletteIndex = 0;
             const nextPaletteColor = () => {
                 if (basePalette.length === 0) return '#999999';
                 const color = basePalette[paletteIndex % basePalette.length];
                 paletteIndex += 1;
                 return color;
             };
             const ctx = canvas.getContext('2d');
             const datasets = series.map((s) => {
                 const label = s.label;
                 const isJupiter = isJupiterLabel(label);
                 const color = isJupiter ? jupiterColor : nextPaletteColor();
                 return {
                     label: label,
                     data: s.data,
                     yAxisID: isRatioMetric(s.key) ? 'y2' : 'y',
                     backgroundColor: color + '20',
                     borderColor: color,
                     borderWidth: 3,
                     fill: false,
                     tension: 0.3,
                     pointRadius: 0
                 };
             });
             countyInsightsChart = new Chart(ctx, {
                 type: 'line',
                 data: { datasets },
                 options: {
                     responsive: true,
                     maintainAspectRatio: false,
                     interaction: { mode: 'index', intersect: false },
                     plugins: {
                         legend: { display: true },
                         title: { display: true, text: title }
                     },
                     scales: {
                         x: { type: 'time', time: { unit: 'month' } },
                         y: { beginAtZero: false },
                         y2: {
                             position: 'right',
                             grid: { drawOnChartArea: false },
                             suggestedMin: 0,
                             suggestedMax: 1,
                             ticks: { callback: (v) => `${Math.round(v * 100)}%` }
                         }
                     }
                 }
             });
         }

         function parseYyyymmToDate(yyyymm) {
             try {
                 const s = String(yyyymm || '');
                 const y = Number(s.slice(0,4));
                 const m = Number(s.slice(4,6));
                 if (!y || !m) return null;
                 return new Date(Date.UTC(y, m - 1, 1));
             } catch { return null; }
         }
         function toNumberOrNull(v) {
             const n = Number(v);
             return isFinite(n) ? n : null;
         }
         function metricLabel(key) {
             switch (key) {
                 case 'avg_listing_price': return 'Average Listing Price';
                 case 'median_listing_price_proxy': return 'Median Listing Price (proxy)';
                 case 'avg_price_per_sqft': return 'Average Price per Sq Ft';
                 case 'avg_days_on_market': return 'Average Days on Market';
                 case 'active_listing_count': return 'Active Listings';
                 case 'new_listing_count': return 'New Listings';
                 case 'pending_ratio': return 'Pending Ratio';
                 case 'price_increased_share': return 'Price Increased Share';
                 case 'price_reduced_share': return 'Price Reduced Share';
                 default: return key;
             }
         }
         function isRatioMetric(key) {
             return key === 'pending_ratio' || key === 'price_increased_share' || key === 'price_reduced_share';
         }
         // Initialize development comparison
         async function initializeDevelopmentComparison() {
             if (window.isPalmBeachCounty === false) {
                 return;
             }
             const t0 = performance.now();
             try {
                 // 1) Try direct-render from saved neighbourhood comparison first (no dropdown population)
                 try {
                     const slugEl = document.getElementById('reportContent');
                     const slug = (typeof urlSlug !== 'undefined') ? urlSlug : (window.location.pathname.split('/').pop());
                     let rendered = false;
                     try {
                         const resp = await fetch(`${API_BASE}/reports/${slug}/neighbourhood-comparison`);
                         if (resp.ok) {
                             const saved = await resp.json();
                             const payload = saved && saved.data ? saved.data : null;
                             // Prefer explicit development/zone arrays from API to avoid misclassification
                             const devs = Array.isArray(payload?.development_names) ? payload.development_names : [];
                             const zonesSaved = Array.isArray(payload?.zone_names) ? payload.zone_names : [];
                             window.selectedDevelopments = devs;
                             window.selectedZones = zonesSaved;

                             // Fetch both data sets in parallel and merge, tagging source type for disambiguation
                             const reqs = [];
                             const reqTypes = [];
                             if (devs.length > 0) {
                                 reqs.push(fetch(`${API_BASE}/developments-comparison?developments=${encodeURIComponent(devs.join(','))}`));
                                 reqTypes.push('development');
                             }
                             if (zonesSaved.length > 0) {
                                 reqs.push(fetch(`${API_BASE}/zones-comparison?zones=${encodeURIComponent(zonesSaved.join(','))}`));
                                 reqTypes.push('zone');
                             }
                             const resps = await Promise.all(reqs);
                             const jsons = await Promise.all(resps.map(r => r.ok ? r.json() : Promise.resolve(null)));
                             let mergedData = [];
                             jsons.forEach((j, idx) => {
                                 if (!j || !j.success) return;
                                 const srcType = reqTypes[idx] || 'development';
                                 if (Array.isArray(j.data)) mergedData.push(...j.data.map(row => ({ ...row, sourceType: srcType })));
                                 else if (Array.isArray(j.data?.comparisonData)) mergedData.push(...j.data.comparisonData.map(row => ({ ...row, sourceType: srcType })));
                             });

                             // Build label mapping and disambiguated labels (mirror Generate Analysis path)
                             const devSetLower = new Set(devs.map(n => String(n).toLowerCase()));
                             const overlapLower = new Set((zonesSaved || []).map(n => String(n).toLowerCase()).filter(n => devSetLower.has(n)));
                             const entityLabelMap = {}; // label -> { name, type }
                             const entityKeyToLabel = {}; // `${type}:${lowerName}` -> label
                             const labels = [];
                             devs.forEach(name => {
                                 const label = String(name);
                                 labels.push(label);
                                 entityLabelMap[label] = { name: String(name), type: 'development' };
                                 entityKeyToLabel[`development:${String(name).toLowerCase()}`] = label;
                             });
                             (zonesSaved || []).forEach(name => {
                                 const lower = String(name).toLowerCase();
                                 const label = overlapLower.has(lower) ? `${name} (Zone)` : String(name);
                                 labels.push(label);
                                 entityLabelMap[label] = { name: String(name), type: 'zone' };
                                 entityKeyToLabel[`zone:${lower}`] = label;
                             });
                             window.entityLabelMap = entityLabelMap;
                             window.entityKeyToLabel = entityKeyToLabel;
                             try {
                                 window.knownDevNamesLower = new Set(devs.map(n => String(n).toLowerCase()));
                                 window.knownZoneNamesLower = new Set((zonesSaved || []).map(n => String(n).toLowerCase()));
                             } catch {}

                             if (mergedData.length > 0) {
                                 displayDevelopmentComparisonChart(mergedData, labels);
                                 showDevelopmentChartView();
                                 const chartControls = document.getElementById('development-chart-controls');
                                 if (chartControls) chartControls.style.display = 'block';
                                 const chartHeader = document.getElementById('dev-comparison-chart-header');
                                 if (chartHeader) chartHeader.style.display = 'block';
                                 if (payload.series_id) {
                                     const type = String(payload.series_id);
                                     if (type === 'sales' || type === 'price' || type === 'price_per_sqft') {
                                         switchDevelopmentChart(type);
                                     }
                                 }
                                 rendered = true;
                             }
                         }
                         else if (resp.status === 404) {
                             // Fallback to complete endpoint
                             rendered = await tryRenderFromComplete(slug);
                         }
                     } catch (e) {
                         // If endpoint missing, try fallback
                         rendered = await tryRenderFromComplete(slug);
                     }
                 } catch (e) {
                     console.warn('Direct-render from saved neighbourhood comparison skipped:', e);
                 }

                 // 2) Prepare controls lazily for edits
                 // Load lists without blocking the main thread
                 loadDevelopmentsList().then(() => {
                     try { populateInitialDevelopmentDropdowns(); } catch {}
                 });
                 // Zones are loaded on demand when toggled
                 createSelectionModeToggle();
                 // Initial dropdown will be populated when developments list resolves above
                 if (selectionMode === 'development') {
                     setTimeout(() => { try { autoSelectReportDevelopment(); } catch {} }, 0);
                 }
                 setupDevelopmentComparisonEventHandlers();
             } catch (error) {
                 console.error('Error initializing development comparison:', error);
             }
             const t1 = performance.now();
             console.log('initializeDevelopmentComparison ms:', Math.round(t1 - t0));
         }

         // Load available developments (full list, once)
         async function loadDevelopmentsList() {
             try {
                 const response = await fetch(`${API_BASE}/developments`);
                 if (!response.ok) {
                     throw new Error(`Failed to load developments: ${response.status}`);
                 }
                 const result = await response.json();
                 
                 // Handle different response structures
                 if (result && result.success && Array.isArray(result.data)) {
                     developmentsList = result.data.map(r => {
                         const name = r.development_name || r.name || r.Development;
                         return { development_name: String(name || '').trim() };
                     }).filter(r => r.development_name.length > 0);
                 } else if (Array.isArray(result)) {
                     developmentsList = result.map(v => ({ development_name: String(v || '').trim() }))
                                               .filter(r => r.development_name.length > 0);
                 } else {
                     developmentsList = [];
                 }
                 
                 console.log('Loaded developments:', developmentsList ? developmentsList.length : 0);
             } catch (error) {
                 console.error('Error loading developments:', error);
                 developmentsList = [];
             }
         }

         // Load available zones (full list, once)
         async function loadZonesList() {
             try {
                 const response = await fetch(`${API_BASE}/zones`);
                 if (!response.ok) {
                     throw new Error(`Failed to load zones: ${response.status}`);
                 }
                 const result = await response.json();

                 if (result && result.success && Array.isArray(result.data)) {
                     zonesList = result.data.map(r => {
                         const name = r.zone_name || r.name || r.Zone;
                         return { zone_name: String(name || '').trim() };
                     }).filter(r => r.zone_name.length > 0);
                 } else if (Array.isArray(result)) {
                     zonesList = result.map(v => ({ zone_name: String(v || '').trim() }))
                                       .filter(r => r.zone_name.length > 0);
                 } else {
                     zonesList = [];
                 }

                 console.log('Loaded zones:', zonesList ? zonesList.length : 0);
             } catch (error) {
                 console.error('Error loading zones:', error);
                 zonesList = [];
             }
         }

         // Create Development/Zone toggle UI
         function createSelectionModeToggle() {
             const controls = document.getElementById('dev-controls-section');
             const container = document.getElementById('development-selections');
             if (!controls && !container) return;

             // Avoid duplicate creation
             if (document.getElementById('selection-mode-toggle')) return;

             const host = controls || container.parentElement;
             const toggleWrap = document.createElement('div');
             toggleWrap.id = 'selection-mode-toggle';
             toggleWrap.style.display = 'flex';
             toggleWrap.style.alignItems = 'center';
             toggleWrap.style.gap = '10px';
             toggleWrap.style.marginBottom = '12px';

             const label = document.createElement('div');
             label.textContent = 'Compare by:';
             label.style.fontWeight = '600';

             const btnGroup = document.createElement('div');
             btnGroup.style.display = 'inline-flex';
             btnGroup.style.border = '1px solid #ced4da';
             btnGroup.style.borderRadius = '6px';
             btnGroup.style.overflow = 'hidden';

             function makeButton(text, mode) {
                 const btn = document.createElement('button');
                 btn.type = 'button';
                 btn.textContent = text;
                 btn.style.padding = '6px 10px';
                 btn.style.fontSize = '12px';
                 btn.style.border = 'none';
                 btn.style.cursor = 'pointer';
                 btn.style.background = (selectionMode === mode) ? '#0d6efd' : '#ffffff';
                 btn.style.color = (selectionMode === mode) ? '#ffffff' : '#333333';
                 btn.addEventListener('click', async () => {
                     if (selectionMode === mode) return;
                     // Capture current UI selections into the correct persisted list BEFORE switching mode
                     try { persistCurrentModeSelections(); } catch (e) { console.warn('persistCurrentModeSelections failed:', e); }
                     selectionMode = mode;
                     // Update visual state
                     devBtn.style.background = (selectionMode === 'development') ? '#0d6efd' : '#ffffff';
                     devBtn.style.color = (selectionMode === 'development') ? '#ffffff' : '#333333';
                     zoneBtn.style.background = (selectionMode === 'zone') ? '#0d6efd' : '#ffffff';
                     zoneBtn.style.color = (selectionMode === 'zone') ? '#ffffff' : '#333333';

                     // Ensure data is loaded
                     if (selectionMode === 'zone' && zonesList.length === 0) {
                         await loadZonesList();
                     }

                     // Rebuild UI for current mode without discarding other mode's selections
                     rebuildSelectionsUIForCurrentMode();

                     // Update any static labels/titles to match mode
                     updateDevZoneStaticLabels();
                 });
                 return btn;
             }

             const devBtn = makeButton('Development', 'development');
             const zoneBtn = makeButton('Waterfront Zone', 'zone');

             btnGroup.appendChild(devBtn);
             btnGroup.appendChild(zoneBtn);

             toggleWrap.appendChild(label);
             toggleWrap.appendChild(btnGroup);

             // Insert above the selections container
             if (controls) {
                 controls.insertBefore(toggleWrap, controls.firstChild);
             } else if (container && container.parentElement) {
                 container.parentElement.insertBefore(toggleWrap, container);
             }
         }

         // Read current dropdown selections from the UI
         function readCurrentSelectionsFromUI() {
             const values = [];
             for (let i = 1; i <= developmentSelectionCount; i++) {
                 const sel = document.getElementById(`development-select-${i}`);
                 if (sel && sel.value) values.push(sel.value);
             }
             return values;
         }

         // Persist the currently displayed tab's selections (development or zone) into the corresponding list
         function persistCurrentModeSelections() {
             const values = readCurrentSelectionsFromUI();
             if (selectionMode === 'development') {
                 window.selectedDevelopments = values.slice();
             } else {
                 window.selectedZones = values.slice();
             }
         }

         // Update static labels and button text between Development and Waterfront Zone
         function updateDevZoneStaticLabels() {
             const noun = (selectionMode === 'development') ? 'Development' : 'Waterfront Zone';
             const nounPlural = (selectionMode === 'development') ? 'developments' : 'waterfront zones';

             const compTitle = document.getElementById('dev-comp-title');
             if (compTitle) compTitle.textContent = `${noun} Comparison Analysis`;

             const controlsTitle = document.getElementById('dev-controls-title');
             if (controlsTitle) controlsTitle.textContent = `${noun} Comparison Analysis`;

             const addBtn = document.getElementById('add-development-btn');
             if (addBtn) addBtn.textContent = `Add ${noun}`;

             const removeBtn = document.getElementById('remove-development-btn');
             if (removeBtn) removeBtn.textContent = `Remove ${noun}`;

             const chartHeaderTitle = document.getElementById('dev-chart-title');
             if (chartHeaderTitle) chartHeaderTitle.textContent = `${noun} Sales Comparison`;

             const chartHeaderSubtitle = document.getElementById('dev-chart-subtitle');
             if (chartHeaderSubtitle) chartHeaderSubtitle.textContent = `Comparative analysis of sales volume and pricing across selected ${nounPlural}`;

             const loadingText = document.getElementById('dev-chart-loading-text');
             if (loadingText) loadingText.textContent = `Generating ${noun.toLowerCase()} comparison analysis...`;
         }

         // Populate initial development dropdowns
         function populateInitialDevelopmentDropdowns() {
             // Create the first development selection
             const container = document.getElementById('development-selections');
             if (container) {
                 const selectionDiv = document.createElement('div');
                 selectionDiv.className = 'location-selection';
                 selectionDiv.id = `development-selection-1`;
                 
                 selectionDiv.innerHTML = `
                     <div class="location-row">
                         <div class="location-field">
                             <label for="development-select-1">${selectionMode === 'development' ? 'Development' : 'Waterfront Zone'} 1</label>
                             <select id="development-select-1" class="fred-select">
                                 <option value="">Select ${selectionMode === 'development' ? 'Development' : 'Waterfront Zone'}...</option>
                             </select>
                         </div>
                     </div>
                 `;
                 
                 container.appendChild(selectionDiv);
                 
                 // Populate the dropdown only if list is ready; otherwise defer
                 const selectEl = document.getElementById('development-select-1');
                 if (selectEl) {
                     const ready = (selectionMode === 'development') ? ((developmentsList||[]).length > 0)
                                                                   : ((zonesList||[]).length > 0);
                     const ensure = () => populateDevelopmentDropdown(selectEl);
                     if (ready) {
                         ensure();
                     } else {
                         let retries = 0;
                         const waitAndPopulate = () => {
                             const nowReady = (selectionMode === 'development') ? ((developmentsList||[]).length > 0)
                                                                             : ((zonesList||[]).length > 0);
                             if (nowReady) {
                                 ensure();
                             } else if (retries < 50) {
                                 retries += 1;
                                 setTimeout(waitAndPopulate, 100);
                             }
                         };
                         setTimeout(waitAndPopulate, 100);
                     }
                 }
             }
         }

         // Populate a single development dropdown (chunked to avoid blocking the UI)
         function populateDevelopmentDropdown(selectElement) {
             const t0 = performance.now();
             if (selectElement.__populating) {
                 // Skip if a population cycle is already in progress for this select
                 console.log('populateDevelopmentDropdown skipped: already populating');
                 return;
             }
             selectElement.__populating = true;
             if (!selectElement) return;

             // Clear existing options and add placeholder
             selectElement.innerHTML = `<option value="">Select ${selectionMode === 'development' ? 'Development' : 'Waterfront Zone'}...</option>`;

             let list;
             if (selectionMode === 'development') {
                 list = (developmentsList || []).map(r => r.development_name);
             } else {
                 list = (zonesList || []).map(r => r.zone_name);
             }
             if (!list || !Array.isArray(list) || list.length === 0) {
                 console.warn('No options available to populate dropdown for mode:', selectionMode);
                 return;
             }

             const CHUNK_SIZE = 100; // smaller chunks for smoother rendering
             let index = 0;

             function addChunk() {
                 const frag = document.createDocumentFragment();
                 const upper = Math.min(index + CHUNK_SIZE, list.length);
                 for (let i = index; i < upper; i++) {
                     const name = list[i];
                     if (!name) continue;
                     const opt = document.createElement('option');
                     opt.value = name;
                     opt.textContent = name;
                     frag.appendChild(opt);
                 }
                 selectElement.appendChild(frag);
                 index = upper;

                 if (index < list.length) {
                     // Yield to the browser to keep UI responsive
                     requestAnimationFrame(addChunk);
                 } else {
                     const t1 = performance.now();
                     console.log('populateDevelopmentDropdown options:', list.length, 'ms:', Math.round(t1 - t0));
                     // Finalize: apply any preselect value if provided
                     const desired = selectElement.dataset && selectElement.dataset.preselect ? String(selectElement.dataset.preselect) : '';
                     if (desired) {
                         for (let j = 0; j < selectElement.options.length; j++) {
                             if (selectElement.options[j].value === desired) {
                                 selectElement.selectedIndex = j;
                                 break;
                             }
                         }
                     }
                     // Mark as done to prevent re-entry
                     selectElement.__populating = false;
                 }
             }

             // Kick off chunked population
             addChunk();
         }
        // Auto-select the development from the report's property address
        function autoSelectReportDevelopment() {
            try {
                // Get the current report's development name
                const reportData = getCurrentReportData();
                if (!reportData || !reportData.development) {
                    console.log('No development found in report data for auto-selection');
                    return;
                }

                const reportDevelopment = reportData.development.trim();
                console.log('Attempting to auto-select development:', reportDevelopment);

                // Find the first development dropdown
                const firstDropdown = document.getElementById('development-select-1');
                if (!firstDropdown) {
                    console.warn('First development dropdown not found');
                    return;
                }

                // Look for exact match or partial match
                let matchFound = false;
                for (let i = 0; i < firstDropdown.options.length; i++) {
                    const option = firstDropdown.options[i];
                    if (option.value === reportDevelopment) {
                        // Exact match
                        firstDropdown.selectedIndex = i;
                        matchFound = true;
                        console.log('Exact match found and selected:', reportDevelopment);
                        break;
                    }
                }

                // If no exact match, try partial match
                if (!matchFound) {
                    for (let i = 0; i < firstDropdown.options.length; i++) {
                        const option = firstDropdown.options[i];
                        if (option.value && (
                            option.value.toLowerCase().includes(reportDevelopment.toLowerCase()) ||
                            reportDevelopment.toLowerCase().includes(option.value.toLowerCase())
                        )) {
                            firstDropdown.selectedIndex = i;
                            matchFound = true;
                            console.log('Partial match found and selected:', option.value, 'for report development:', reportDevelopment);
                            break;
                        }
                    }
                }

                if (!matchFound) {
                    console.log('No matching development found in dropdown for:', reportDevelopment);
                }

            } catch (error) {
                console.error('Error auto-selecting report development:', error);
            }
        }

        // Setup event handlers for development comparison
        function setupDevelopmentComparisonEventHandlers() {
            // Add development button
            const addDevelopmentBtn = document.getElementById('add-development-btn');
            if (addDevelopmentBtn) {
                addDevelopmentBtn.addEventListener('click', addDevelopmentSelection);
            }

            // Remove development button
            const removeDevelopmentBtn = document.getElementById('remove-development-btn');
            if (removeDevelopmentBtn) {
                removeDevelopmentBtn.addEventListener('click', () => {
                    // Remove the last development selection
                    const container = document.getElementById('development-selections');
                    if (container && container.children.length > 1) {
                        const lastChild = container.lastElementChild;
                        lastChild.remove();
                        updateDevelopmentButtons();
                    }
                });
            }

            // Reset button
            const resetDevelopmentBtn = document.getElementById('reset-development-comparison-btn');
            if (resetDevelopmentBtn) {
                resetDevelopmentBtn.addEventListener('click', resetDevelopmentComparison);
            }

            // Generate comparison button
            const generateDevelopmentBtn = document.getElementById('compare-developments-btn');
            if (generateDevelopmentBtn) {
                generateDevelopmentBtn.addEventListener('click', generateDevelopmentComparison);
            }

            // Back to controls button
            const backToDevControlsBtn = document.getElementById('back-to-dev-controls-btn');
            if (backToDevControlsBtn) {
                backToDevControlsBtn.addEventListener('click', showDevelopmentControlsView);
            }

            // Handle chart type dropdown changes
            const chartTypeSelect = document.getElementById('development-chart-type-select');
            if (chartTypeSelect) {
                chartTypeSelect.addEventListener('change', (e) => switchDevelopmentChart(e.target.value));
            }
        }

        // Add new development selection
        function addDevelopmentSelection() {
            developmentSelectionCount++;
            const container = document.getElementById('development-selections');
            
            const selectionDiv = document.createElement('div');
            selectionDiv.className = 'location-selection';
            selectionDiv.id = `development-selection-${developmentSelectionCount}`;
            
            selectionDiv.innerHTML = `
                <div class="location-row">
                    <div class="location-field">
                        <label for="development-select-${developmentSelectionCount}">${selectionMode === 'development' ? 'Development' : 'Waterfront Zone'} ${developmentSelectionCount}</label>
                        <select id="development-select-${developmentSelectionCount}" class="fred-select">
                            <option value="">Select ${selectionMode === 'development' ? 'Development' : 'Waterfront Zone'}...</option>
                        </select>
                    </div>
                    <button type="button" id="remove-development-btn-${developmentSelectionCount}" class="remove-location-btn" style="margin-left: 10px;">
                        Remove
                    </button>
                </div>
            `;
            
            container.appendChild(selectionDiv);
            const removeBtn = document.getElementById(`remove-development-btn-${developmentSelectionCount}`);
            if (removeBtn) {
                const currentId = developmentSelectionCount;
                removeBtn.addEventListener('click', () => removeDevelopmentSelection(currentId));
            }
            
            // Populate the new dropdown without blocking; defer if list not ready
            const newSelect = document.getElementById(`development-select-${developmentSelectionCount}`);
            if (newSelect) {
                if (developmentsList && developmentsList.length > 0) {
                    setTimeout(() => populateDevelopmentDropdown(newSelect), 0);
                } else {
                    let retries = 0;
                    const waitAndPopulateNew = () => {
                        if (developmentsList && developmentsList.length > 0) {
                            populateDevelopmentDropdown(newSelect);
                        } else if (retries < 50) {
                            retries += 1;
                            setTimeout(waitAndPopulateNew, 100);
                        }
                    };
                    setTimeout(waitAndPopulateNew, 100);
                }
            }
            
            // Update button visibility
            updateDevelopmentButtons();
        }

        // Render a development selection at a specific index WITHOUT incrementing global count
        function renderDevelopmentSelectionAt(index, preselectName) {
            const container = document.getElementById('development-selections');
            if (!container) return;

            // If already exists, skip
            if (document.getElementById(`development-selection-${index}`)) return;

            const selectionDiv = document.createElement('div');
            selectionDiv.className = 'location-selection';
            selectionDiv.id = `development-selection-${index}`;

            selectionDiv.innerHTML = `
                <div class="location-row">
                    <div class="location-field">
                        <label for="development-select-${index}">${selectionMode === 'development' ? 'Development' : 'Waterfront Zone'} ${index}</label>
                        <select id="development-select-${index}" class="fred-select">
                            <option value="">Select ${selectionMode === 'development' ? 'Development' : 'Waterfront Zone'}...</option>
                        </select>
                    </div>
                </div>
            `;

            container.appendChild(selectionDiv);

            const selectEl = document.getElementById(`development-select-${index}`);
            if (selectEl) {
                if (preselectName) selectEl.dataset.preselect = String(preselectName);
                // Populate list based on current mode; use zones list for zone mode
                const ready = (selectionMode === 'development') ? (developmentsList && developmentsList.length > 0)
                                                               : (zonesList && zonesList.length > 0);
                const ensurePopulate = () => populateDevelopmentDropdown(selectEl);
                if (ready) {
                    setTimeout(ensurePopulate, 0);
                } else {
                    let retries = 0;
                    const waitAndPopulate = () => {
                        const nowReady = (selectionMode === 'development') ? (developmentsList && developmentsList.length > 0)
                                                                          : (zonesList && zonesList.length > 0);
                        if (nowReady) {
                            ensurePopulate();
                        } else if (retries < 50) {
                            retries += 1;
                            setTimeout(waitAndPopulate, 100);
                        }
                    };
                    setTimeout(waitAndPopulate, 100);
                }
            }
        }

        // Remove development selection
        function removeDevelopmentSelection(selectionId) {
            const selectionDiv = document.getElementById(`development-selection-${selectionId}`);
            if (selectionDiv) {
                selectionDiv.remove();
            }
            
            // Update button visibility
            updateDevelopmentButtons();
        }

        // Update development button visibility
        function updateDevelopmentButtons() {
            const addBtn = document.getElementById('add-development-btn');
            const removeBtn = document.getElementById('remove-development-btn');
            const container = document.getElementById('development-selections');
            const currentSelections = container ? container.children.length : 0;
            
            if (addBtn) {
                addBtn.style.display = currentSelections >= 10 ? 'none' : 'inline-block';
            }
            if (removeBtn) {
                removeBtn.style.display = currentSelections <= 1 ? 'none' : 'inline-block';
            }
        }
        // Rebuild the selections UI to reflect the current mode using persisted lists
        function rebuildSelectionsUIForCurrentMode() {
            const container = document.getElementById('development-selections');
            if (!container) return;
            container.innerHTML = '';

            const list = (selectionMode === 'development') ? (window.selectedDevelopments || []) : (window.selectedZones || []);
            const targetCount = Math.max(1, list.length);
            let i = 1;
            function addNext() {
                if (i <= targetCount) {
                    const pre = list[i - 1] || '';
                    renderDevelopmentSelectionAt(i, pre);
                    i += 1;
                    requestAnimationFrame(addNext);
                } else {
                    developmentSelectionCount = targetCount;
                    updateDevelopmentButtons();
                }
            }
            requestAnimationFrame(addNext);
        }

        // Reset development comparison to default
        function resetDevelopmentComparison() {
            developmentSelectionCount = 1;
            const container = document.getElementById('development-selections');
            
            // Clear all selections
            if (container) {
                container.innerHTML = '';
            }
            
            // Recreate the first selection
            populateInitialDevelopmentDropdowns();
            updateDevelopmentButtons();

            // Also update static labels to current mode
            updateDevZoneStaticLabels();
            
            // Clear any existing chart and hide chart view
            if (window.developmentChart) {
                window.developmentChart.destroy();
                window.developmentChart = null;
            }
            
            // Clear stored data
            window.developmentComparisonData = null;
            window.selectedDevelopments = null;
            
            // Hide chart elements
            const chartControls = document.getElementById('development-chart-controls');
            if (chartControls) chartControls.style.display = 'none';
            
            const chartHeader = document.getElementById('dev-comparison-chart-header');
            if (chartHeader) chartHeader.style.display = 'none';
            
            // Show controls view
            showDevelopmentControlsView();
        }

        // Generate development comparison
        async function generateDevelopmentComparison() {
            // Collect current-mode selections
            const selections = [];
            let hasValidSelections = false;
            
            for (let i = 1; i <= developmentSelectionCount; i++) {
                const developmentSelect = document.getElementById(`development-select-${i}`);
                
                if (developmentSelect && developmentSelect.value) {
                    selections.push(developmentSelect.value);
                    hasValidSelections = true;
                }
            }
            
            if (!hasValidSelections) {
                alert(`Please select at least one ${selectionMode === 'development' ? 'development' : 'zone'} to compare`);
                return;
            }
            
            // Show loading state
            const loadingDiv = document.getElementById('dev-chart-loading');
            const errorDiv = document.getElementById('dev-chart-error');
            const chartContainer = document.getElementById('dev-comparison-chart');
            
            if (loadingDiv) loadingDiv.style.display = 'flex';
            if (errorDiv) errorDiv.style.display = 'none';
            if (chartContainer) chartContainer.innerHTML = '';
            
            try {
                // Persist the currently displayed tab's selections
                persistCurrentModeSelections();
                // Combine both sets to render a single chart (distinct lists). Do not coerce types.
                const devs = Array.isArray(window.selectedDevelopments) ? window.selectedDevelopments.slice() : [];
                const zones = Array.isArray(window.selectedZones) ? window.selectedZones.slice() : [];

                // Build label mapping to disambiguate identical names across types
                const devSetLower = new Set(devs.map(n => String(n).toLowerCase()));
                const overlapLower = new Set(zones.map(n => String(n).toLowerCase()).filter(n => devSetLower.has(n)));
                const entityLabelMap = {}; // label -> { name, type }
                const entityKeyToLabel = {}; // `${type}:${lowerName}` -> label
                const labels = [];
                devs.forEach(name => {
                    const label = String(name);
                    labels.push(label);
                    entityLabelMap[label] = { name: String(name), type: 'development' };
                    entityKeyToLabel[`development:${String(name).toLowerCase()}`] = label;
                });
                zones.forEach(name => {
                    const lower = String(name).toLowerCase();
                    const label = overlapLower.has(lower) ? `${name} (Zone)` : String(name);
                    labels.push(label);
                    entityLabelMap[label] = { name: String(name), type: 'zone' };
                    entityKeyToLabel[`zone:${lower}`] = label;
                });
                window.entityLabelMap = entityLabelMap;
                window.entityKeyToLabel = entityKeyToLabel;

                // Fetch both groups in parallel and tag with sourceType
                const requests = [];
                const requestTypes = [];
                if (devs.length > 0) {
                    requests.push(fetch(`${API_BASE}/developments-comparison?developments=${encodeURIComponent(devs.join(','))}`));
                    requestTypes.push('development');
                }
                if (zones.length > 0) {
                    requests.push(fetch(`${API_BASE}/zones-comparison?zones=${encodeURIComponent(zones.join(','))}`));
                    requestTypes.push('zone');
                }
                const responses = await Promise.all(requests);
                const jsons = await Promise.all(responses.map(r => r.ok ? r.json() : Promise.resolve(null)));
                let merged = [];
                jsons.forEach((j, idx) => {
                    if (!j || !j.success) return;
                    const srcType = requestTypes[idx] || 'development';
                    if (Array.isArray(j.data)) merged.push(...j.data.map(row => ({ ...row, sourceType: srcType })));
                    else if (Array.isArray(j.data?.comparisonData)) merged.push(...j.data.comparisonData.map(row => ({ ...row, sourceType: srcType })));
                });

                // Display merged data; order labels as devs then zones (with suffixes as needed)
                displayDevelopmentComparisonChart(merged, labels);
                
                // Switch to chart view and show chart elements
                showDevelopmentChartView();
                
                // Show chart controls
                const chartControls = document.getElementById('development-chart-controls');
                if (chartControls) {
                    chartControls.style.display = 'block';
                }
                
                // Show chart header
                const chartHeader = document.getElementById('dev-comparison-chart-header');
                if (chartHeader) {
                    chartHeader.style.display = 'block';
                }

                // Non-blocking save to DB (neighbourhood) — persist mixed items (developments + zones)
                try {
                    const slug = (typeof urlSlug !== 'undefined') ? urlSlug : (window.location.pathname.split('/').pop());
                    const seriesIdToSave = (typeof currentDevelopmentChart === 'string' && currentDevelopmentChart) ? currentDevelopmentChart : 'sales';
                    const items = [
                        ...devs.map(name => ({ name, type: 'development' })),
                        ...zones.map(name => ({ name, type: 'zone' }))
                    ];
                    await fetch(`${API_BASE}/reports/${slug}/neighbourhood-comparison`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ series_id: seriesIdToSave, items })
                    });
                } catch (persistErr) {
                    console.warn('Neighbourhood save failed:', persistErr);
                }
                
            } catch (error) {
                console.error('Error generating development comparison:', error);
                if (errorDiv) {
                    errorDiv.style.display = 'block';
                    errorDiv.innerHTML = `
                        <p>Failed to generate comparison chart</p>
                        <p class="error-details">${error.message}</p>
                    `;
                }
            } finally {
                if (loadingDiv) loadingDiv.style.display = 'none';
            }
        }

        // Global variable to store chart data
        let developmentChartData = null;
        let currentDevelopmentChart = 'sales';

        // Display development comparison chart
        function displayDevelopmentComparisonChart(data, developments) {
            console.log('displayDevelopmentComparisonChart called with:', { data, developments });
            // Process rows by type-aware label so dev and zone with same name remain separate
            const keyToLabel = (typeof window.entityKeyToLabel === 'object') ? window.entityKeyToLabel : {};
            const processedByLabel = {};

            data.forEach(row => {
                const baseName = row.development_name || row.zone_name || row.name;
                const lower = String(baseName || '').toLowerCase();
                // Enhanced type detection: prefer explicit sourceType, then explicit fields, then known name sets
                const knownDev = (window.knownDevNamesLower && typeof window.knownDevNamesLower.has === 'function') ? window.knownDevNamesLower.has(lower) : false;
                const knownZone = (window.knownZoneNamesLower && typeof window.knownZoneNamesLower.has === 'function') ? window.knownZoneNamesLower.has(lower) : false;
                const sourceType = (typeof row.sourceType === 'string') ? row.sourceType : null;
                const isZone = (sourceType === 'zone') || (!!row.zone_name && (!row.development_name || row.development_name.length === 0)) || (knownZone && !knownDev);
                const key = `${isZone ? 'zone' : 'development'}:${lower}`;
                const label = keyToLabel[key] || (isZone ? `${baseName} (Zone)` : String(baseName));
                const year = row.sale_year || row.year;

                if (!processedByLabel[label]) {
                    processedByLabel[label] = {};
                }

                const avgPrice = parseFloat(row.avg_price ?? row.average_price) || 0;
                const avgSqft = parseFloat(row.avg_sqft ?? row.average_sqft) || 0;
                const pricePerSqft = avgSqft > 0 ? avgPrice / avgSqft : 0;

                processedByLabel[label][year] = {
                    sales_count: parseInt(row.sales_count) || 0,
                    avg_price: avgPrice,
                    avg_price_per_sqft: pricePerSqft
                };
            });

            console.log('Processed data (by label):', Object.keys(processedByLabel));

            // Store processed data globally (do not mutate persisted selections here)
            window.developmentComparisonData = processedByLabel;
            // Track the exact entities (developments and/or zones) used for this chart render
            try { window.comparisonEntities = Array.isArray(developments) ? developments.slice() : []; } catch {}
            
            // Check if we have any price per sqft data available
            let hasPricePerSqftData = false;
            Object.values(processedByLabel).forEach(devData => {
                Object.values(devData).forEach(yearData => {
                    if (yearData.avg_price_per_sqft > 0) {
                        hasPricePerSqftData = true;
                    }
                });
            });
            
            // Store data availability for UI decisions
            window.hasPricePerSqftData = hasPricePerSqftData;
            
            // Update dropdown options based on data availability
            updateChartTypeDropdown();
            
            // Display initial chart (sales)
            console.log('About to call renderDevelopmentChart');
            renderDevelopmentChart('sales');
        }

        // Global Chart.js instance
        let developmentChart = null;
        // Render custom two-line HTML legend with ( Map | Stats ) per series
        function renderDevelopmentHtmlLegend() {
            try {
                const legendContainer = document.getElementById('devLegend');
                if (!legendContainer || !developmentChart) return;

                // Clear any existing items
                legendContainer.innerHTML = '';

                const datasets = developmentChart.data && developmentChart.data.datasets
                    ? developmentChart.data.datasets
                    : [];

                datasets.forEach((dataset, index) => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';

                    // Row 1: dot + name (click toggles visibility)
                    const nameRow = document.createElement('div');
                    nameRow.className = 'legend-name';

                    const dot = document.createElement('span');
                    dot.className = 'legend-dot';
                    dot.style.backgroundColor = dataset.borderColor || '#3498db';

                    const nameText = document.createElement('span');
                    nameText.textContent = dataset.label || `Series ${index + 1}`;

                    nameRow.appendChild(dot);
                    nameRow.appendChild(nameText);

                    nameRow.addEventListener('click', () => {
                        const currentlyVisible = developmentChart.isDatasetVisible(index);
                        developmentChart.setDatasetVisibility(index, !currentlyVisible);
                        developmentChart.update();
                        renderDevelopmentHtmlLegend();
                    });

                    // Apply hidden styling
                    if (!developmentChart.isDatasetVisible(index)) {
                        nameRow.style.opacity = '0.5';
                        nameRow.style.textDecoration = 'line-through';
                    }

                    // Row 2: ( Map | Stats ) actions
                    const actionsRow = document.createElement('div');
                    actionsRow.className = 'legend-actions';

                    const openParen = document.createTextNode('( ');
                    const pipeText = document.createTextNode(' | ');
                    const closeParen = document.createTextNode(' )');

                    const mapLink = document.createElement('a');
                    mapLink.href = '#';
                    mapLink.textContent = 'Map';
                    mapLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        const label = dataset.label || '';
                        if (label) {
                            const entity = (window.entityLabelMap && window.entityLabelMap[label]) || { name: label, type: (Array.isArray(window.selectedZones) && window.selectedZones.includes(label)) ? 'zone' : 'development' };
                            openDevelopmentMapForName(entity.name, entity.type);
                        }
                    });

                    const statsLink = document.createElement('a');
                    statsLink.href = '#';
                    statsLink.textContent = 'Stats';
                    statsLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        const label = dataset.label || '';
                        if (label) {
                            const entity = (window.entityLabelMap && window.entityLabelMap[label]) || { name: label, type: (Array.isArray(window.selectedZones) && window.selectedZones.includes(label)) ? 'zone' : 'development' };
                            showChartOverlay(entity.name, entity.type);
                        }
                    });

                    actionsRow.appendChild(openParen);
                    actionsRow.appendChild(mapLink);
                    actionsRow.appendChild(pipeText);
                    actionsRow.appendChild(statsLink);
                    actionsRow.appendChild(closeParen);

                    item.appendChild(nameRow);
                    item.appendChild(actionsRow);

                    legendContainer.appendChild(item);
                });
            } catch (legendErr) {
                console.warn('Failed to render custom development legend:', legendErr);
            }
        }

        // Render development chart based on type using Chart.js
                function renderDevelopmentChart(chartType, chartMetaOverride) {
            console.log('renderDevelopmentChart called with chartType:', chartType);
            const chartCanvas = document.getElementById('dev-comparison-chart');
            console.log('Chart canvas found:', !!chartCanvas);
            console.log('Development comparison data exists:', !!window.developmentComparisonData);
            
            if (!chartCanvas || !window.developmentComparisonData) {
                console.log('Early return - missing canvas or data');
                return;
            }
            
            const data = window.developmentComparisonData;
            const labelToEntity = (typeof window.entityLabelMap === 'object') ? window.entityLabelMap : {};
            const developments = Array.isArray(window.comparisonEntities) && window.comparisonEntities.length > 0
                ? window.comparisonEntities
                : (Array.isArray(window.selectedDevelopments) ? window.selectedDevelopments : []);
            console.log('About to process chart with data:', data, 'entities:', developments);
            
            const chartMeta = chartMetaOverride || DEVELOPMENT_CHART_TYPES[chartType] || DEVELOPMENT_CHART_TYPES.sales;
            const dataKey = chartMeta.dataKey || 'sales_count';
            const chartTitleLabel = chartMeta.title || 'Sales Count';
            const isYoYChart = !!chartMeta.yoy;
            
            const allYears = new Set();
            Object.values(data).forEach(devData => {
                Object.keys(devData).forEach(year => allYears.add(parseInt(year)));
            });
            const years = Array.from(allYears).sort((a, b) => a - b);
            console.log('Years found:', years);
            
            if (developmentChart) {
                developmentChart.destroy();
            }
            
            const datasets = developments.map((label, index) => {
                const entity = labelToEntity[label] || { name: label, type: 'development' };
                const dataKeyForEntity = data[label] || data[entity.name] || {};
                let developmentData = years.map(year => {
                    const yearData = dataKeyForEntity[year] ? dataKeyForEntity[year][dataKey] : null;
                    if (yearData == null || yearData === 0 || isNaN(yearData)) return null;
                    return yearData;
                });
                
                if (isYoYChart) {
                    let lastValue = null;
                    let hasAnchor = false;
                    developmentData = developmentData.map(value => {
                        if (!Number.isFinite(value)) {
                            return hasAnchor ? null : null;
                        }
                        if (!hasAnchor) {
                            hasAnchor = true;
                            lastValue = value;
                            return 0;
                        }
                        if (!Number.isFinite(lastValue) || lastValue === 0) {
                            lastValue = value;
                            return null;
                        }
                        const change = ((value - lastValue) / lastValue) * 100;
                        lastValue = value;
                        return Number.isFinite(change) ? Number(change.toFixed(chartMeta.decimals ?? 1)) : null;
                    });
                }
                
                const colors = [
                    '#3498db',
                    '#e74c3c',
                    '#2ecc71',
                    '#f39c12',
                    '#9b59b6',
                    '#1abc9c',
                    '#34495e',
                    '#e67e22',
                    '#95a5a6',
                    '#8e44ad'
                ];
                
                return {
                    label,
                    data: developmentData,
                    backgroundColor: colors[index % colors.length] + '20',
                    borderColor: colors[index % colors.length],
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointBackgroundColor: colors[index % colors.length],
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    pointRadius: (window.innerWidth <= 768 ? 0 : 5),
                    pointHoverRadius: (window.innerWidth <= 768 ? 0 : 7),
                    pointHoverBackgroundColor: colors[index % colors.length],
                    pointHoverBorderColor: '#ffffff',
                    clip: 0
                };
            });
            
            const flatValues = datasets.flatMap(ds => (ds.data || []).filter(v => v != null && !isNaN(v)));
            const yMin = flatValues.length ? Math.min(...flatValues) : 0;
            const yMax = flatValues.length ? Math.max(...flatValues) : 1;
            const yPad = (yMax - yMin) * 0.08;
            const allowNegative = chartMeta.valueType === 'percent';
            const suggestedMin = allowNegative ? (yMin - yPad) : Math.max(0, yMin - yPad);
            const suggestedMax = yMax + yPad * 0.5;

            const config = {
                type: 'line',
                data: {
                    labels: years,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    elements: {
                        point: {
                            radius: (window.innerWidth <= 768 ? 0 : 3),
                            hitRadius: (window.innerWidth <= 768 ? 4 : 6),
                            hoverRadius: (window.innerWidth <= 768 ? 0 : 4)
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `${selectionMode === 'development' ? 'Development' : 'Waterfront Zone'} Trends - ${chartTitleLabel}`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#ffffff',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${formatMetricValue(context.parsed.y, chartMeta)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            offset: true,
                            title: {
                                display: true,
                                text: 'Year'
                            },
                            grid: {
                                display: true,
                                color: '#f0f0f0',
                                borderDash: [2, 2]
                            }
                        },
                        y: Object.assign({
                            grid: {
                                display: true,
                                color: '#f0f0f0'
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    return formatMetricValue(value, chartMeta);
                                }
                            }
                        }, computeYAxisConfig(chartMeta, datasets))
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeInOutQuart'
                    }
                }
            };
            
            config.options.scales.y.suggestedMin = suggestedMin;
            config.options.scales.y.suggestedMax = suggestedMax;
            
            const ctx = chartCanvas.getContext('2d');
            developmentChart = new Chart(ctx, config);

            renderDevelopmentHtmlLegend();
            
            console.log('Chart.js chart created successfully');
        }
        // Show the development actions popup
        function showDevelopmentActionsPopup(event, developmentName) {
            console.log('showDevelopmentActionsPopup called:', { event, developmentName });
            
            // Remove the link emoji from the development name if it exists
            const cleanDevelopmentName = String(developmentName || '').replace(/^🔗\s*/, '').trim();
            console.log('Clean development name:', cleanDevelopmentName);
            
            const popup = document.getElementById('developmentActionsPopup');
            const title = document.getElementById('developmentPopupTitle');
            const mapBtn = document.getElementById('developmentPopupMapBtn');
            const chartBtn = document.getElementById('developmentPopupChartBtn');
            
            console.log('Popup elements found:', { popup: !!popup, title: !!title, mapBtn: !!mapBtn, chartBtn: !!chartBtn });
            
            if (!popup || !title || !mapBtn || !chartBtn) {
                console.error('Missing popup elements');
                return;
            }
            
            // Set the development name
            title.textContent = cleanDevelopmentName;

            // Always show Map button (works for Development and Zone)
            try {
                mapBtn.style.display = 'flex';
            } catch (err) {
                console.warn('Error adjusting Map button visibility:', err);
            }
            
            // Position the popup near the mouse click (use clientX/Y for fixed positioning)
            let x = (typeof event.clientX === 'number' ? event.clientX : (typeof event.pageX === 'number' ? (event.pageX - window.pageXOffset) : (window.__lastMouse ? window.__lastMouse.x : 200))) + 10; // Default to 200 if no coordinates
            let y = (typeof event.clientY === 'number' ? event.clientY : (typeof event.pageY === 'number' ? (event.pageY - window.pageYOffset) : (window.__lastMouse ? window.__lastMouse.y : 200))) - 50; // Default to 200 if no coordinates
            
            // For debugging: always show at a visible location
            if (x < 50 || y < 50) {
                console.log('Using fallback position due to invalid coordinates');
                x = 200;
                y = 200;
            }
            
            // Ensure popup stays within viewport boundaries
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const popupWidth = 180; // Approximate popup width
            const popupHeight = 120; // Approximate popup height
            
            if (x + popupWidth > viewportWidth) {
                x = viewportWidth - popupWidth - 10;
            }
            if (y < 0) {
                y = 10;
            }
            if (y + popupHeight > viewportHeight) {
                y = viewportHeight - popupHeight - 10;
            }
            
            console.log('Final popup position:', { x, y });
            
            popup.style.left = Math.round(x) + 'px';
            popup.style.top = Math.round(y) + 'px';
            popup.style.display = 'block';
            popup.style.position = 'fixed';
            popup.style.zIndex = '9999';
            
            console.log('Popup should now be visible at:', popup.style.left, popup.style.top);
            
            // Debug: Check computed styles
            const computedStyle = window.getComputedStyle(popup);
            console.log('Popup computed styles:', {
                display: computedStyle.display,
                position: computedStyle.position,
                zIndex: computedStyle.zIndex,
                left: computedStyle.left,
                top: computedStyle.top,
                visibility: computedStyle.visibility,
                opacity: computedStyle.opacity
            });
            
            // Debug: Check if popup is actually in the DOM
            console.log('Popup in DOM:', document.contains(popup));
            console.log('Popup dimensions:', {
                offsetWidth: popup.offsetWidth,
                offsetHeight: popup.offsetHeight,
                clientWidth: popup.clientWidth,
                clientHeight: popup.clientHeight
            });
            
            // Add event listeners for the buttons
            mapBtn.onclick = function() {
                hideDevelopmentActionsPopup();
                openDevelopmentMapForName(cleanDevelopmentName);
            };
            
            chartBtn.onclick = function() {
                hideDevelopmentActionsPopup();
                showChartOverlay(cleanDevelopmentName);
            };
            
            // Add hover effects
            [mapBtn, chartBtn].forEach(btn => {
                btn.onmouseenter = function() {
                    this.style.backgroundColor = '#f8f9fa';
                    this.style.transform = 'translateY(-1px)';
                };
                
                btn.onmouseleave = function() {
                    this.style.backgroundColor = '#ffffff';
                    this.style.transform = 'translateY(0)';
                };
            });
        }
        
        // Hide the development actions popup
        function hideDevelopmentActionsPopup() {
            const popup = document.getElementById('developmentActionsPopup');
            popup.style.display = 'none';
        }
        // Open development map for a specific development name
        async function openDevelopmentMapForName(developmentName, typeHint) {
            const modal = document.getElementById('mapModal');
            const loading = document.getElementById('mapLoading');
            const error = document.getElementById('mapError');
            const subtitle = document.getElementById('mapSubtitle');
            const title = document.getElementById('mapTitle');
            const loadingText = document.getElementById('mapLoadingText');
            const errorContext = document.getElementById('mapErrorContext');
            
            if (!developmentName || !developmentName.trim()) {
                showMapError('No development name provided.');
                return;
            }
            
            const cleanDevelopmentName = developmentName.trim();
            const inZoneMode = (typeof typeHint === 'string')
                ? (typeHint === 'zone')
                : (typeof selectionMode !== 'undefined' && selectionMode === 'zone');
            title.textContent = inZoneMode ? 'Waterfront Zone Parcels Map' : 'Development Parcels Map';
            subtitle.textContent = `Showing parcels for ${cleanDevelopmentName}`;
            loadingText.textContent = inZoneMode ? 'Loading waterfront zone parcels...' : 'Loading development parcels...';
            errorContext.textContent = inZoneMode ? 'Could not load parcel data for this waterfront zone.' : 'Could not load parcel data for this development.';
            
            // Show modal and loading state
            modal.style.display = 'block';
            loading.style.display = 'flex';
            error.style.display = 'none';
            
            try {
                // Fetch parcel data
                const url = inZoneMode
                    ? `${API_BASE}/zone-parcels/${encodeURIComponent(cleanDevelopmentName)}`
                    : `${API_BASE}/development-parcels/${encodeURIComponent(cleanDevelopmentName)}`;
                const response = await fetch(url);
                const result = await response.json();
                
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Failed to load parcel data');
                }
                
                if (!result.data || !result.data.features || result.data.features.length === 0) {
                    throw new Error(inZoneMode ? 'No parcel data found for this zone' : 'No parcel data found for this development');
                }
                
                // Hide loading
                loading.style.display = 'none';
                
                // Initialize or update map with the new development
                currentDevelopmentName = cleanDevelopmentName;
                initializeMap(result.data);
                
            } catch (error) {
                console.error('Error loading development map:', error);
                showMapError(error.message || 'Unable to load map data for this development.');
            }
        }

        // Update chart type dropdown based on data availability
        function updateChartTypeDropdown() {
            const chartTypeSelect = document.getElementById('development-chart-type-select');
            if (!chartTypeSelect) return;
            
            const sqftOptionValues = ['price_per_sqft', 'price_per_sqft_yoy'];
            sqftOptionValues.forEach(value => {
                const optionEl = chartTypeSelect.querySelector(`option[value="${value}"]`);
                if (!optionEl) return;
                if (window.hasPricePerSqftData) {
                    optionEl.disabled = false;
                    optionEl.style.color = '';
                    optionEl.textContent = value === 'price_per_sqft'
                        ? 'Price Per Square Foot'
                        : 'Price Per Square Foot (YoY %)';
                } else {
                    optionEl.disabled = true;
                    optionEl.style.color = '#999';
                    optionEl.textContent = value === 'price_per_sqft'
                        ? 'Price Per Square Foot (No Data Available)'
                        : 'Price Per Square Foot (YoY % - No Data)';
                }
            });
        }

            // Switch between chart types
        function switchDevelopmentChart(chartType) {
            let resolvedType = chartType;
            let chartMeta = DEVELOPMENT_CHART_TYPES[resolvedType] || DEVELOPMENT_CHART_TYPES.sales;
            if (chartMeta.requiresPricePerSqft && !window.hasPricePerSqftData) {
                console.warn('Price per sqft data not available, falling back to sales chart');
                resolvedType = 'sales';
                chartMeta = DEVELOPMENT_CHART_TYPES[resolvedType];
            }
            
            currentDevelopmentChart = resolvedType;
            
            // Update dropdown selection
            const chartTypeSelect = document.getElementById('development-chart-type-select');
            if (chartTypeSelect && chartTypeSelect.value !== resolvedType) {
                chartTypeSelect.value = resolvedType;
            }
            
            // Render the appropriate chart
            renderDevelopmentChart(resolvedType, chartMeta);
            // Update legend for new datasets
            renderDevelopmentHtmlLegend();
        }

        // Show the development controls view and hide the chart view
        function showDevelopmentControlsView() {
            document.getElementById('dev-controls-section').style.display = 'block';
            document.getElementById('dev-chart-section').style.display = 'none';
            // Rebuild strictly from current mode's persisted list to avoid cross-mode pollution
            rebuildSelectionsUIForCurrentMode();
        }
        
        // Show the development chart view and hide the controls view  
        function showDevelopmentChartView() {
            document.getElementById('dev-controls-section').style.display = 'none';
            document.getElementById('dev-chart-section').style.display = 'block';
        }

        // Initialize development comparison when page loads
        document.addEventListener('DOMContentLoaded', function() {
            if (window.isPalmBeachCounty !== false) {
                setTimeout(initializeDevelopmentComparison, 1500);
            }
        });
    </script>

    <!-- Map Modal -->
    <div id="mapModal" style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        overflow: hidden;
    ">
        <div style="
            position: relative;
            width: 95%;
            height: 95%;
            margin: 2.5% auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        ">
            <!-- Modal Header -->
            <div style="
                padding: 20px 30px;
                border-bottom: 1px solid #e9ecef;
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: #f8f9fa;
                border-radius: 12px 12px 0 0;
            ">
                <div>
                    <h2 id="mapTitle" style="margin: 0; color: #2c3e50; font-size: 24px; font-weight: 600;">Development Parcels Map</h2>
                    <p style="margin: 5px 0 0; color: #6c757d; font-size: 14px;" id="mapSubtitle">Loading development data...</p>
                </div>
                <button id="closeMapModal" style="
                    background: none;
                    border: none;
                    font-size: 28px;
                    color: #6c757d;
                    cursor: pointer;
                    padding: 0;
                    width: 40px;
                    height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 8px;
                    transition: all 0.2s ease;
                " onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='none'">
                    ×
                </button>
            </div>

            <!-- Map Container -->
            <div style="flex: 1; position: relative; overflow: hidden;">
                <div id="developmentMap" style="width: 100%; height: 100%;"></div>
                
                <!-- Loading Overlay -->
                <div id="mapLoading" style="
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(255, 255, 255, 0.9);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                ">
                    <div style="text-align: center;">
                        <div style="
                            border: 4px solid #f3f3f3;
                            border-top: 4px solid #3498db;
                            border-radius: 50%;
                            width: 50px;
                            height: 50px;
                            animation: spin 1s linear infinite;
                            margin: 0 auto 20px;
                        "></div>
                        <p id="mapLoadingText" style="margin: 0; color: #2c3e50; font-size: 16px; font-weight: 500;">Loading development parcels...</p>
                    </div>
                </div>

                <!-- Error Message -->
                <div id="mapError" style="
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: white;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                ">
                    <div style="text-align: center; max-width: 400px; padding: 40px;">
                        <div style="color: #e74c3c; font-size: 48px; margin-bottom: 20px;">🗺️</div>
                        <h3 style="margin: 0 0 15px; color: #2c3e50; font-size: 20px;">Unable to Load Map</h3>
                        <p style="margin: 0; color: #6c757d; font-size: 14px;" id="mapErrorMessage">
                            <span id="mapErrorContext">Could not load parcel data for this development.</span>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
